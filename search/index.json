[{"content":"Khởi động nhẹ nhàng: How To Predict Random Numbers Generated By Computers\n1. Python Hàm random của Python sử dụng thuật toán Mersenne Twister - với 624 số nguyên 32 bit làm trạng thái, sau đó cứ mỗi lần xuất ra một số nguyên 32 bit, nó sẽ thay đổi trạng thái.\nMersenne Twister Ta sẽ phân tích thuật toán tạo số ngẫu nhiên trong khoảng [0,0xffffffff]: Link\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 /* Period parameters -- These are all magic. Don\u0026#39;t change. */ #define N 624 #define M 397 #define MATRIX_A 0x9908b0dfU /* constant vector a */ #define UPPER_MASK 0x80000000U /* most significant w-r bits */ #define LOWER_MASK 0x7fffffffU /* least significant r bits */ static uint32_t genrand_uint32(RandomObject *self) { uint32_t y; static const uint32_t mag01[2] = {0x0U, MATRIX_A}; /* mag01[x] = x * MATRIX_A for x=0,1 */ uint32_t *mt; mt = self-\u0026gt;state; if (self-\u0026gt;index \u0026gt;= N) { /* generate N words at one time */ int kk; for (kk=0;kk\u0026lt;N-M;kk++) { y = (mt[kk]ANDUPPER_MASK)|(mt[kk+1]ANDLOWER_MASK); mt[kk] = mt[kk+M] ^ (y \u0026gt;\u0026gt; 1) ^ mag01[y AND 0x1U]; } for (;kk\u0026lt;N-1;kk++) { y = (mt[kk]ANDUPPER_MASK)|(mt[kk+1]ANDLOWER_MASK); mt[kk] = mt[kk+(M-N)] ^ (y \u0026gt;\u0026gt; 1) ^ mag01[y AND 0x1U]; } y = (mt[N-1]ANDUPPER_MASK)|(mt[0]ANDLOWER_MASK); mt[N-1] = mt[M-1] ^ (y \u0026gt;\u0026gt; 1) ^ mag01[y AND 0x1U]; self-\u0026gt;index = 0; } y = mt[self-\u0026gt;index++]; y ^= (y \u0026gt;\u0026gt; 11); y ^= (y \u0026lt;\u0026lt; 7) AND 0x9d2c5680U; y ^= (y \u0026lt;\u0026lt; 15) AND 0xefc60000U; y ^= (y \u0026gt;\u0026gt; 18); return y; } Nếu index \u0026gt;= N (= 624), nghĩa là đã dùng hết số trong mảng mt[] và do đó phải tạo lại 624 số tiếp theo. Mảng mt[] được thay đổi bằng quá trình sau:\n1 2 3 4 5 y = (mt[kk] AND UPPER_MASK) | (mt[(kk + 1) % N] AND LOWER_MASK) mt[kk] = mt[(kk + M) % N] ^ (y \u0026gt;\u0026gt; 1) ^ mag01[y AND 0x1U] y = (mt[N-1]ANDUPPER_MASK)|(mt[0]ANDLOWER_MASK); mt[N-1] = mt[M-1] ^ (y \u0026gt;\u0026gt; 1) ^ mag01[y AND 0x1U]; Sau đó, số y ngẫu nhiên được tạo như sau:\n1 2 3 4 5 6 y = mt[self-\u0026gt;index++]; y ^= (y \u0026gt;\u0026gt; 11); y ^= (y \u0026lt;\u0026lt; 7) AND 0x9d2c5680U; y ^= (y \u0026lt;\u0026lt; 15) AND 0xefc60000U; y ^= (y \u0026gt;\u0026gt; 18); return y; Do đó, nếu ta có thể đảo ngược được quá trình này thì ta có thể dự đoán giá trị tiếp theo khi biết được 624 đầu ra 32 bit.\nKhôi phục từ đầu ra đầy đủ 32-bit Sau đây là các bước đảo ngược chi tiết: y ^= (y \u0026gt;\u0026gt; 18)\nĐây là dịch phải 18 bit, ảnh hưởng từ bit cao tới bit thấp và sau bước này thì bit cao không thay đổi cùng với việc $18*2 = 36 \u0026gt; 32$ nên ta chỉ cần 1 lần đảo là được.\n1 2 # Step 1 y ^= (y \u0026gt;\u0026gt; 18) y ^= (y \u0026lt;\u0026lt; 15) AND 0xefc60000\nỞ đây, mask 0xefc60000 có cấu trúc đặc biệt với làm phép biển đổi trở thành 1 hàm tự nghịch đảo, nghĩa là $f(f(x))=x$, với $f(x) = x \\oplus ((x \u0026laquo; 15)$ AND 0xefc60000). Chứng minh:\nĐặt A = 0xefc60000. Khi đó: $f(y)=f(f(x)) = f(x \\oplus ((x \u0026laquo; 15) AND \\ A))$\n$= (x \\oplus ((x \u0026laquo; 15) AND \\ A)) \\oplus (((x \\oplus ((x \u0026laquo; 15) AND \\ A)) \u0026laquo; 15) AND \\ A)$\n$= (x \\oplus ((x \u0026laquo; 15) AND \\ A)) \\oplus (((x \u0026laquo; 15) AND \\ A) \\oplus((x \u0026laquo; 30) AND (A \u0026laquo; 15) AND \\ A))$\n$= x \\oplus (((x \u0026laquo; 15) AND \\ A) \\oplus ((x \u0026laquo; 15) AND \\ A)) \\oplus((x \u0026laquo; 30) AND (A \u0026laquo; 15) \\ AND \\ A) = x$\n(vì tính chất $P \\oplus P = 0$ và $A$ có 17 bit thấp là 0 nên nếu dịch trái 15 bit thì 32 bit cuối của $A \u0026laquo; 15$ sẽ đều là 0 nên $(A \u0026laquo; 15) AND \\ A = 0$)\nDo đó, để đảo ngược thì ta chỉ cần 1 lần biến đổi hàm nữa:\n1 2 # Step 2 y ^= (y \u0026lt;\u0026lt; 15) AND 0xefc60000 y ^= (y \u0026lt;\u0026lt; 7) AND 0x9d2c5680\nỞ bước này thì ta sẽ thiết lập một hàm dịch bit gần tương tự như bước trên:\nĐặt B = 0x9d2c5680. Với $y = x \\oplus ((x \u0026laquo; 7) AND \\ B)$ , ta sẽ dùng hàm $f(x\u0026rsquo;) = y \\oplus ((x\u0026rsquo; \u0026laquo; 7) AND \\ B)$ Khi đó: $f_4(y) = f_4(x \\oplus ((x \u0026laquo; 7) AND \\ B)) = f_3(y \\oplus (((x \\oplus ((x \u0026laquo; 7) AND \\ B)) \u0026laquo; 7)AND \\ B))$\n$= f_3(x \\oplus (((x \u0026laquo; 7) AND \\ B) \\oplus ((x \u0026laquo; 7) AND \\ B)) \\oplus((x \u0026laquo; (7\\times2))AND (B \u0026laquo; 7) AND \\ B))$\n$= f_3(x \\oplus((x \u0026laquo; (7\\times2))AND (B \u0026laquo; 7) AND \\ B))$\n$= f_2(x \\oplus((x \u0026laquo; (7\\times3))AND (B \u0026laquo; (7\\times2)) AND (B \u0026laquo; 7) AND \\ B))$\n$= f(x \\oplus((x \u0026laquo; (7\\times4))AND (B\u0026laquo; (7\\times3)) AND (B \u0026laquo; (7\\times2)) AND (B \u0026laquo; 7) AND \\ B))$\n$= x \\oplus((x \u0026laquo; (7\\times5))AND (B\u0026laquo; (7\\times4)) AND (B\u0026laquo; (7\\times3)) AND (B \u0026laquo; (7\\times2)) AND (B \u0026laquo; 7) AND \\ B)$\n$=x$\n(vì B có 7 bit thấp là 0 nên nếu dịch trái 28 bit thì 32 bit cuối của $B \u0026laquo; 28$ sẽ đều là 0 nên đẳng thức trên xảy ra.)\nDo đó, để đảo ngược thì ta chỉ cần 4 lần biến đổi hàm như sau:\n1 2 3 4 5 # Step 3 res = y for _ in range(4): res = y ^ (res \u0026lt;\u0026lt; 7) AND 0x9d2c5680 y = res y ^= (y \u0026gt;\u0026gt; 11) Đây là dịch phải 11 bit, ảnh hưởng từ bit cao tới bit thấp và sau bước này thì bit cao không thay đổi cùng với việc $11*3 = 33 \u0026gt; 32$ nên ta chỉ cần 2 lần đảo để khôi phục từ bit cao đến bit thấp.\n1 2 3 4 # Step 4 res = y for _ in range(2): res = y ^ (res \u0026gt;\u0026gt; 11) Tổng hợp lại thì ta có hàm đảo (untemper):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def untemper(y): # 1. Rev: y ^= (y \u0026gt;\u0026gt; 18) y ^= (y \u0026gt;\u0026gt; 18) # 2. Rev: y ^= (y \u0026lt;\u0026lt; 15) AND 0xefc60000 y ^= (y \u0026lt;\u0026lt; 15) AND 0xefc60000 # 3. Rev: y ^= (y \u0026lt;\u0026lt; 7) AND 0x9d2c5680 temp = y for _ in range(4): temp = y ^ (temp \u0026lt;\u0026lt; 7) AND 0x9d2c5680 y = temp # 4. Rev: y ^= (y \u0026gt;\u0026gt; 11); temp = y for _ in range(2): temp = y ^ (temp \u0026gt;\u0026gt; 11) y = temp return y Ví dụ cụ thể:\n1 2 3 4 5 6 7 8 9 10 import random state = random.getstate() outputs = [random.getrandbits(32) for _ in range(1000)] recovered_state = (3, tuple([untemper(v) for v in outputs[:624]] + [0]), None) random.setstate(recovered_state) for i in range(1000): assert outputs[i] == random.getrandbits(32) State được phục hồi có 3 phần tử: Số nguyên 3, là chỉ số \u0026ldquo;vị trí trạng thái\u0026rdquo; được module random của Python sử dụng để chỉ ra vị trí của bộ tạo trong mảng trạng thái. Bộ dữ liệu gồm 624 số nguyên, biểu diễn mảng trạng thái đã phục hồi. None là \u0026ldquo;giá trị giữ chỗ\u0026rdquo; để đảm bảo tính tương thích với định dạng trạng thái mà module random của Python mong đợi. Khi chạy đoạn kiểm thử trên thì dòng lệnh đối chiếu với assert không bị lỗi, chứng tỏ đã khôi phục thành công state ban đầu.\n2. Javascript Phương thức tĩnh Math.random() trả về một số dấu phẩy động, ngẫu nhiên lớn hơn hoặc bằng 0 và nhỏ hơn 1, với phân phối gần như đồng đều trong phạm vi đó — sau đó bạn có thể điều chỉnh theo phạm vi mong muốn. Việc triển khai sẽ chọn seed ban đầu cho thuật toán tạo số ngẫu nhiên; người dùng không thể chọn hoặc đặt lại seed này.\nXorShift128 trả về trạng thái 128-bit qua state0, state1 và được triển khai như sau: 1 2 3 4 5 6 7 8 9 def xs128(state0, state1): mask = (1 \u0026lt;\u0026lt; 64) - 1 s1 = state0 AND mask s0 = state1 AND mask s1 ^= (s1 \u0026lt;\u0026lt; 23) AND mask s1 ^= (s1 \u0026gt;\u0026gt; 17) AND mask s1 ^= s0 s1 ^= (s0 \u0026gt;\u0026gt; 26) AND mask return s0, s1 Khi cache trống, 1 chuỗi 64 giá trị ngẫu nhiên mới sẽ được tạo thành qua xs128 và lưu trữ trong cache với chỉ số được đặt ở cuối. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def _refill(self): \u0026#34;\u0026#34;\u0026#34; Refill the Math.random cache using xs128. Can only be used when Math.random cache is empty. A new 64-long list of random values is stored in cache. The cache_idx is set to the last index of the cache (63). \u0026#34;\u0026#34;\u0026#34; assert self.cache_idx == -1 self.cache = [] for _ in range(64): self.state0, self.state1 = xs128(self.state0, self.state1) self.cache.append(self.state0) self.cache_idx = 63 Lúc gọi Math.random() thì next() được gọi và đưa ra 1 giá trị thập phân từ 0.0 đến 1.0. Ở đây thì v8 chuyển đổi số từ xs128 sang double bằng cách bỏ 12 bit cuối, còn 52 bit thì đưa vào phần Mantissa của số double trong chuẩn IEEE754. Sau đó trừ đi 1 và có được giá trị thập phân từ 0.0 đến 1.0. 1 2 3 4 5 6 7 8 9 10 11 12 13 def v8_to_double(state0, debug): r = (state0 \u0026gt;\u0026gt; 12) | 0x3ff0000000000000 if debug: return r else: return struct.unpack(\u0026#39;d\u0026#39;, struct.pack(\u0026#39;\u0026lt;Q\u0026#39;, r))[0] - 1 def next(self): if self.cache_idx \u0026lt; 0: self._refill() val = v8_to_double(self.cache[self.cache_idx], self.debug) self.cache_idx -= 1 return val Khôi phục trạng thái từ một lượng giá trị ngẫu nhiên được cho Math.random() của V8 sử dụng xs128 gồm các biểu thức tuyến tính trong hệ GF(2). Do đó, ta có thể xây dựng một hệ các phương trình tuyến tính trên GF(2) với 1 lượng giá trị ngẫu nhiên cho trước vừa đủ và từ đó, ta được nghiệm của hệ này là hai trạng thái ban đầu (seed) của thuật toán và dự đoán được giá trị ngẫu nhiên tiếp theo.\nChúng ta sẽ xây dựng hệ như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 numbers = [ 0.20850633840727073, 0.28382289045651743, 0.4071416957057805, 0.3101367279739642, 0.6813711566813534, 0.8365880507655776, 0.2238039081275922, 0.014754643967695324, 0.44290438850282876, 0.5473214381957232, 0.40023560591139606, 0.14837298522461473, 0.12321774476187275, 0.8501766788936596, 0.9212308144118708, 0.8099337802981195, 0.06047989985671265, 0.6552969701254443, 0.5803218168252511, 0.41915921494443964, 0.9153038363744563, 0.7403989120318095, 0.6630141727527132, 0.5230661117641415 ] Đây là những giá trị ngẫu nhiên cho trước 1 2 3 4 5 6 7 from gf2bv import LinearSystem lin = LinearSystem([64] * 2) state0, state1 = lin.gens() Random = MathRandom(state0, state1, True) out = [Random.next() for _ in range(len(numbers))] state0, state1 là hai symbolic unknown có 64-bit và nằm trong hệ tuyến tính. Random sẽ tạo những biểu thức tuyến tính chính là out với ẩn là state0, state1 để xây dựng hệ. 1 zeros=[(v8_from_double(x) \u0026gt;\u0026gt; 12 | 0x3ff0000000000000) ^ y for x,y in zip(numbers, out)] Với mỗi cặp giá trị và phương trình ẩn, ta khôi phục 52 bit mantissa của đầu ra và đưa về chuẩn IEEE754 cho dạng double + 1.0 rồi XOR với biểu thức ẩn đã cho. Nếu biểu thức này trùng với giá trị đầu ra thì sau khi XOR sẽ bằng 0. Vậy là ta đã có hệ tuyến tính ẩn state0, state1, giải hệ này và ta nhận được trạng thái ban đầu. 1 sol = lin.solve_one(zeros) 3. C/C++ Bên ngôn ngữ C/C++, hàm rand() xây dựng dựa trên GLIBC random number generator\nHàm random() của thư viện GNU C cung cấp các số giả ngẫu nhiên thông qua phương pháp phản hồi cộng tuyến tính. Phản hồi này tuyến tính theo modulo $2^{32}$. Tính phi tuyến tính nhỏ duy nhất xuất hiện trong giai đoạn seeding, do phép này được thực hiện theo modulo $2^{31} - 1$ chứ không phải modulo $2^{31}$ hay $2^{32}$. Điều này có nghĩa là, mặc dù mỗi số ngẫu nhiên được tạo ra phụ thuộc tuyến tính vào các số trước đó trong chuỗi, nhưng toàn bộ các số ngẫu nhiên không phụ thuộc tuyến tính vào seed.\nThuật toán Như mô tả ở trên, ta có: $2147483647 = 2^{31} - 1$ và $4294967296 = 2^{32}$\nVới mỗi seed cho trước, 1 initialization vector (iv) $r_0\u0026hellip;r_{33}$ được tính như sau:\n$r_0$ = seed $r_i\\equiv (16807 * r_{i-1}) \\mod 2147483647 \\ ( i \\in [1,30])$ $r_i=r_{i-31}\\ (i\\in [31, 33])$ Sau đó, 1 chuỗi các số ngẫu nhiên $r_{34}\u0026hellip;$ được tạo bằng vòng lặp phản hồi tuyến tính:\n$r_i\\equiv r_{i-3}+r_{i-31}\\mod 4294967296 \\ (i \\ge 34)$ $r_0\u0026hellip;r_{343}$ không được sử dụng mà đầu ra $o_i$ của hàm rand() là: $o_i =r_{i+344} \\gg 1$\nCode in C:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;stdio.h\u0026gt; #define MAX 1000 #define seed 1 main() { int r[MAX]; int i; r[0] = seed; for (i=1; i\u0026lt;31; i++) { r[i] = (16807LL * r[i-1]) % 2147483647; if (r[i] \u0026lt; 0) { r[i] += 2147483647; } } for (i=31; i\u0026lt;34; i++) { r[i] = r[i-31]; } for (i=34; i\u0026lt;344; i++) { r[i] = r[i-31] + r[i-3]; } for (i=344; i\u0026lt;MAX; i++) { r[i] = r[i-31] + r[i-3]; printf(\u0026#34;%d\\n\u0026#34;, ((unsigned int)r[i]) \u0026gt;\u0026gt; 1); } } Khôi phục Phân tích thuật toán trên thì ta thấy rằng:\nTừ $i\\ge34$, $r_i\\equiv r_{i-3}+r_{i-31}$ là tuyến tính và có nghĩa là khi ta biết được 2 trong 3 giá trị thì sẽ suy ra được giá trị còn lại. Với đầu ra $o_i =r_{i+344} \\gg 1$, nghĩa là nó có 31 bit và mất bit bên phải ngoài cùng $r_{i+344}$ Nghĩa là nếu ta có đủ đầu ra liên tiếp thì hoàn toàn có thể lan truyền để khôi phục lại mảng trạng thái ban đầu (iv). Các bước để khôi phục iv như sau:\nĐoán bit thấp bị bỏ rồi ghép thành một phần trạng thái: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 def crack(outputs): states = [] for i in range(len(outputs)): if (i \u0026gt;= 31 and outputs[i] != None and outputs[i - 31] != None and outputs[i - 3] != None and outputs[i] != (outputs[i - 31] + outputs[i - 3]) AND 0x7fffffff ): states[i - 31] = (outputs[i - 31] \u0026lt;\u0026lt; 1) + 1 states[i - 3] = (outputs[i - 3] \u0026lt;\u0026lt; 1) + 1 states.append((outputs[i] \u0026lt;\u0026lt; 1) + 0) else: states.append(None) return states Nếu ta có $o_i, o_{i-31},o_{i-3}$ và chúng không thỏa:\n1 outputs[i] == (outputs[i - 31] + outputs[i - 3]) AND 0x7fffffff Đoán trạng thái của nỏ ở dạng: $$ \\begin{cases} s_{i-31} = o_{i-31} \u003c\u003c 1 + 1 \\\\ s_{i-3} = o_{i-3} \u003c\u003c 1 + 1 \\\\ s_i = o_i \u003c\u003c 1 + 0 \\end{cases} $$Nếu không, gắn $s_i =$ None vì chưa biết dạng chuẩn.\nKhôi phục trạng thái: Chạy ngược công thức cộng để khôi phục các giá trị (nếu có) trong 344 giá trị đầu\n1 2 3 4 5 6 7 8 states = crack(outputs) init = [None] * 344 for i in range(343, 2, -1): s31 = states[i + 31 - 344] if i + 31 \u0026gt;= 344 else init[i + 31] s28 = states[i + 28 - 344] if i + 28 \u0026gt;= 344 else init[i + 28] if s31 is not None and s28 is not None: init[i] = (s31 - s28) % 2**32 Nếu có 1 giá trị trong khoảng 31 giá trị đầu, ta có thể tính tất cả các giá trị còn lại vì tính chất tuyến tính bằng công thức: $r_i\\equiv (16807 * r_{i-1}) \\mod 2147483647 \\Leftrightarrow r_{i-1}\\equiv (16807^{-1} * r_i) \\mod 2147483647$\n1 2 3 4 5 6 base_idx = next((i for i in range(31) if init[i] is not None), None) if base_idx is not None: for i in range(31): if init[i] is None: init[i] = pow(16807, i - base_idx, 2147483647) * init[base_idx] % 2147483647 Vì tính chất tuyến tính $r_i \\equiv r_{i-3}+r_{i-31}, \\forall i \\ge 34$ nên nếu ta biết 2 giá trị thì suy ra được giá trị còn lại. Do đó, ta viết hàm lặp đến khi không thể khôi phục giá trị nào nữa để điền tất cả các giá trị còn thiếu.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def self_recover(states): MOD = 2 ** 32 length = len(states) while True: updated = False for i in range(34, length): s_i = states[i] s_31 = states[i - 31] s_3 = states[i - 3] if s_i is not None and s_3 is not None and s_31 is None: states[i - 31] = (s_i - s_3) % MOD updated = True elif s_i is not None and s_31 is not None and s_3 is None: states[i - 3] = (s_i - s_31) % MOD updated = True elif s_i is None and s_3 is not None and s_31 is not None: states[i] = (s_3 + s_31) % MOD updated = True if not updated: break all_states = init + states self_recover(all_states) Điền 3 giá trị đầu bằng các sao chép từ thứ tự 31 và lấy được seed ban đầu:\n1 2 for i in range(3): all_states[i] = all_states[i + 31] Full code ở đây\u0026hellip;\n4. Golang PRNG của Golang xây dựng dựa trên Lagged Fibonacci Generator.\nThuật toán Hàm tạo seed cho rng: $x_{n+1} = 48271 * x_n \\mod (2^{31} - 1)$\n1 2 3 4 5 6 7 8 9 10 11 def seedrand(x): A = 48271 Q = 44488 R = 3399 hi = x // Q lo = x % Q x = A * lo - R * hi if x \u0026lt; 0: x += INT32_MAX return x Để tránh tràn số thì code dùng Schrage’s Method (hi = x // Q, lo = x % Q).\nTiếp theo, ta có class RNGSource là PRNG chính.\n1 2 self.tap = 0 self.feed = RNG_LEN - RNG_TAP # 607 - 273 = 334 Hai con trỏ là tap và feed chạy ngược nhau, thực hiện phép cộng sinh số ngẫu nhiên rồi sau đó lưu trữ trạng thái này vào mảng vec, tổng 607 phần tử 64-bit.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 def seed(self, seed): self.tap = 0 self.feed = RNG_LEN - RNG_TAP seed %= INT32_MAX if seed \u0026lt; 0: seed += INT32_MAX if seed == 0: seed = 89482311 x = int(seed) for i in range(-20, RNG_LEN): x = seedrand(x) if i \u0026gt;= 0: u = (int(x) \u0026lt;\u0026lt; 40) AND 0xFFFFFFFFFFFFFFFF x = seedrand(x) u ^= (int(x) \u0026lt;\u0026lt; 20) AND 0xFFFFFFFFFFFFFFFF x = seedrand(x) u ^= int(x) u ^= rng_cooked[i] self.vec[i] = u Hàm seed() sẽ nhận giá trị seed và tạo ra mảng trạng thái vec như sau:\nx được gọi seedrand() 20 lần để tạo số ngẫu nhiên. Ghép 3 giá trị 31-bit thành số 64-bit qua hàm seedrand() với $x \u0026laquo; 40, x \u0026laquo; 20, x$. XOR với 1 giá trị trong bảng rng_cooked[]. Tiếp theo, ta sẽ sinh số ngẫu nhiên 64-bit qua vec bằng hàm uint64():\n1 2 3 4 5 6 7 8 9 10 11 12 def uint64(self): self.tap -= 1 if self.tap \u0026lt; 0: self.tap += RNG_LEN self.feed -= 1 if self.feed \u0026lt; 0: self.feed += RNG_LEN x = (self.vec[self.feed] + self.vec[self.tap]) AND 0xFFFFFFFFFFFFFFFF self.vec[self.feed] = x return x Hai con trỏ tap và feed đi lùi trong vòng có độ dài 607. Theo đó là công thức Additive Lagged-Fibonacci Generator: $$ vec_{feed}=(vec_{feed} + vec_{tap}) AND 0xFFFFFFFFFFFFFFFF $$ 1 2 x = (self.vec[self.feed] + self.vec[self.tap]) AND 0xFFFFFFFFFFFFFFFF self.vec[self.feed] = x Khôi phục Như ta thấy, trong golang thì từ sau giai đoạn sinh seed, giai đoạn sinh số ngẫu nhiên chỉ gồm phép cộng tuyến tính trên chuỗi seed lấy được. Nghĩa là nếu ta có chuỗi đầu ra đủ dài, ta có thể xây dựng hệ phương trình tuyến tính để tính chuỗi seed ban đầu.\nĐể xây dựng được hệ như vậy, mình nghĩ ngay tới z3-solver và sau đây là phần crack:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from rng import * from z3 import * s = Solver() NUM_TEST = 700 vec = [BitVec(f\u0026#39;vec_{i}\u0026#39;, 64) for i in range(RNG_LEN)] rng_equation = RngSource(vec) equations = [rng_equation.uint64() for _ in range(NUM_TEST)] rng_value = RngSource() rng_value.seed(int(input(\u0026#34;Enter seed: \u0026#34;))) vals = [rng_value.uint64() for _ in range(NUM_TEST)] for i in range(NUM_TEST): s.add(equations[i] == vals[i]) print(\u0026#34;99%...\u0026#34;) if s.check() == sat: model = s.model() array_values = [model.evaluate(vec[i]).as_long() for i in range(RNG_LEN)] rng = RngSource(array_values) for _ in range(NUM_TEST): res = rng.uint64() for _ in range(10): print(rng.uint64(), rng_value.uint64()) 5. Bash Bash dùng linear congruential generator (LCG) là biến thể của thuật toán Park–Miller “minimal standard” để tạo số ngẫu nhiên 31-bit.\nThuật toán Hàm next_seed sinh seed mới bằng cách áp dụng công thức Park-Miller LCG: $$ X_{k+1}=(a\\times X_k)\\mod m $$với $a = 16807,\\ m = 2^{31} - 1$\n1 2 3 4 5 6 7 8 9 def next_seed(self) -\u0026gt; int: if self.seed == 0: self.seed = 123459876 h = self.seed // 127773 l = self.seed - (127773 * h) t = 16807 * l - 2836 * h self.seed = (t + 0x7fffffff) if t \u0026lt; 0 else t return self.seed Giống Golang, nhằm tránh bị tràn số thì ta dùng Schrage’s Method để tách h và l.\nVới seed đó, ta sinh giá trị ngẫu nhiên bằng hàm next_16:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def next_16(self) -\u0026gt; int: self.next_seed() if self.is_old: # Bash 5.0 and earlier result = self.seed AND BASH_RAND_MAX else: # Bash 5.1 and later result = ((self.seed \u0026gt;\u0026gt; 16) ^ (self.seed AND 0xffff)) AND BASH_RAND_MAX # Skip if same as last if result == self.last: return self.next_16() self.last = result return result Có 2 phiên bản khác nhau:\nTừ bản Bash 5.0 trở xuống, ta chỉ lấy 15 bit thấp. Bash 5.1 trở lên: XOR 2 giá trị 16 bit cao và 16 bit thấp của seed rồi trả về 15 bit cuối. Bên cạnh đó, nếu số mới giống số cũ, ta bỏ qua và tính số mới.\nKhôi phục Vì ở đây, ta không có được trực tiếp $X_n$ mà chỉ lấy được giá trị của nó sau hàm next_16 nên không thể truy ngược được Park-Miller LCG. Do đó, kỹ thuật mình có thể sử dụng ở đây để crack là brute-force.\nMặt khác output chỉ cho 15 bit, trong khi state có 31 bit, thế nên chắc chắn có rất nhiều state cho ra cùng 1 giá trị output. Để lọc được state phù hợp, ta cần nhiều giá trị output liên tiếp để chắc chắn tìm được duy nhất 1 state. Nếu không có nhiều output như vậy, ta có thể tìm những state phù hợp để thử và tìm ra kết quả cuối cùng.\nDo seed có 32 bit, ta nên sử dụng nhiều luồng nhằm chia các khoảng của nó và chạy các task song song để giảm thời gian thực hiện và tối ưu hóa bộ nhớ. Ở đây, mình sử dụng Pool của thư viện multiprocessing trong Python để chia luồng, rồi thực hiện các task duyệt, so sánh với đầu ra cho trước và trả về seed nếu khớp. Full code ở đây\u0026hellip;\nAll code in Github https://github.com/R1MURUN0PR0/Crack_random/tree/main\nTài liệu https://soon.haari.me/import-random/ https://rbtree.blog/posts/2021-05-18-breaking-python-random-module/ https://github.com/JorianWoltjer/BashRandomCracker?tab=readme-ov-file https://en.wikipedia.org/wiki/Xorshift https://github.com/maple3142/gf2bv https://www.mscs.dal.ca/~selinger/random/ https://github.com/d0nutptr/v8_rand_buster ","date":"2025-09-15T20:31:17+07:00","image":"https://r1muru2006.github.io/p/crack-random-module/random_hu_3bc2a96e64581a0.webp","permalink":"https://r1muru2006.github.io/p/crack-random-module/","title":"Crack Random Module"},{"content":" Shout out to others member for trying their best and reached the top 15 of the world, ranked 1st University of Technology.\nleaky-rsa chall.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #!/usr/local/bin/python3 import json from Crypto.Util.number import getPrime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from secrets import randbelow, token_bytes from hashlib import sha256 with open(\u0026#39;flag.txt\u0026#39;) as f: flag = f.read() p = getPrime(512) q = getPrime(512) n = p * q e = 65537 d = pow(e, -1, (p-1)*(q-1)) key_m = randbelow(n) key_c = pow(key_m, e, n) key = sha256(str(key_m).encode()).digest()[:16] iv = token_bytes(16) ct = AES.new(key, AES.MODE_CBC, IV=iv).encrypt(pad(flag.encode(), 16)) print(json.dumps({\u0026#39;n\u0026#39;: n, \u0026#39;c\u0026#39;: key_c, \u0026#39;iv\u0026#39;: iv.hex(), \u0026#39;ct\u0026#39;: ct.hex()})) def get_bit(n, k): return (n \u0026gt;\u0026gt; k) % 2 for _ in range(1024): idx = randbelow(4) print(json.dumps({\u0026#39;idx\u0026#39;: idx})) try: response = json.loads(input()) c = response[\u0026#39;c\u0026#39;] % n assert c != key_c m = pow(c, d, n) b = get_bit(m, idx) except (json.JSONDecodeError, TypeError, KeyError, ValueError, AssertionError): b = 2 print(json.dumps({\u0026#39;b\u0026#39;: b})) print(key_m) Phân tích và lời giải Nhìn sơ qua thì đây là một bài ứng dụng thuật AES-RSA\nSơ đồ chính của thử thách là: Random key_m bé hơn n -\u0026gt; dùng key_m mã hóa flag thành ct bằng AES mode CBC. Mặt khác: Dùng RSA mã hóa key_m thành key_c Cuối cùng tiết lộ n, key_c, iv, ct và cho ta gửi 1024 bản mã. Với mỗi bản mã, tiết lộ 1 bit nằm trong khoảng vị trí thứ 0 đến 3 từ phải qua sau khi giải mã với thuật RSA.\nTuy nhiên trong bài này, key_m đã bị leak khi hoàn thành 1024 bản mã và thế là ta có thể giải mã được AES mode CBC ngay\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # solution.py from Crypto.Cipher import AES from Crypto.Util.Padding import unpad from hashlib import sha256 from pwn import * import json context.log_level = \u0026#39;debug\u0026#39; # io = process([\u0026#39;python3\u0026#39;, \u0026#39;chall.py\u0026#39;]) io = remote(\u0026#34;leaky-rsa.chal.imaginaryctf.org\u0026#34;, 1337) io.recvline() data = json.loads(io.recvline()) n, iv, ct, c = data[\u0026#39;n\u0026#39;], bytes.fromhex(data[\u0026#39;iv\u0026#39;]), bytes.fromhex(data[\u0026#39;ct\u0026#39;]), data[\u0026#39;c\u0026#39;] count = 0 for _ in range(1024): idx = json.loads(io.recvline())[\u0026#39;idx\u0026#39;] send = json.dumps({\u0026#39;c\u0026#39;: 0}).encode() io.sendline(send) b = json.loads(io.recvline())[\u0026#39;b\u0026#39;] count += 1 print(count) key_m = int(io.recvline().decode()) key = sha256(str(key_m).encode()).digest()[:16] flag = unpad(AES.new(key, AES.MODE_CBC, IV=iv).decrypt(ct), 16).decode() print(flag) Flag: ictf{p13cin9_7h3_b1t5_t0g37her_3f0068c1b9be2547ada52a8020420fb0} zkpow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 #!/usr/bin/env python3 import hashlib, secrets, json, time # --- Utility functions --- def sha256(b: bytes) -\u0026gt; bytes: return hashlib.sha256(b).digest() def hexf(b: bytes) -\u0026gt; str: return b.hex() def commit_vertex(v: int, color_label: int, nonce: bytes) -\u0026gt; bytes: return sha256(b\u0026#34;vertex:\u0026#34; + str(v).encode() + b\u0026#34;:\u0026#34; + str(color_label).encode() + b\u0026#34;:\u0026#34; + nonce) # --- Merkle tree helpers --- def build_merkle_tree(leaves_hex): leaves = [bytes.fromhex(h) for h in leaves_hex] if len(leaves) == 0: return hexf(sha256(b\u0026#34;\u0026#34;)), [[sha256(b\u0026#34;\u0026#34;)]] levels = [leaves] cur = leaves while len(cur) \u0026gt; 1: nxt = [] for i in range(0, len(cur), 2): left = cur[i] right = cur[i+1] if i+1 \u0026lt; len(cur) else left nxt.append(sha256(left + right)) levels.append(nxt) cur = nxt return hexf(levels[-1][0]), levels def merkle_proof_for_index(levels, index): proof = [] idx = index for level in levels[:-1]: if idx % 2 == 0: sib_index = idx + 1 if idx + 1 \u0026lt; len(level) else idx sibling = level[sib_index] proof.append((hexf(sibling), False)) else: sib_index = idx - 1 sibling = level[sib_index] proof.append((hexf(sibling), True)) idx //= 2 return proof def verify_merkle_proof(root_hex, leaf_hex, proof): cur = bytes.fromhex(leaf_hex) for sibling_hex, sibling_is_left in proof: sibling = bytes.fromhex(sibling_hex) if sibling_is_left: cur = sha256(sibling + cur) else: cur = sha256(cur + sibling) return hexf(cur) == root_hex # --- Fiat-Shamir edge selection --- def fiat_shamir_select_index(root_hex, m): return int.from_bytes(hashlib.sha256(root_hex.encode()).digest(), \u0026#34;big\u0026#34;) % m # --- Configurable graph generator --- def make_graph(n_vertices=1000, p_good=0.75, p_bad=0.003): coloring = [secrets.randbelow(3) for _ in range(n_vertices)] parts = {0: [], 1: [], 2: []} for v, c in enumerate(coloring): parts[c].append(v) edges = [] for c1 in range(3): for c2 in range(c1+1, 3): A, B = parts[c1], parts[c2] for u in A: for v in B: if secrets.randbelow(1_000_000) / 1_000_000 \u0026lt; p_good: edges.append((u, v)) # spice things up :) for c in range(3): part = parts[c] for i in range(len(part)): for j in range(i+1, len(part)): if secrets.randbelow(1_000_000) / 1_000_000 \u0026lt; p_bad: edges.append((part[i], part[j])) return edges, n_vertices # --- zkPoW prover --- def zkpow_prove(edges, coloring, n_vertices=1000): verts = list(range(n_vertices)) # permutation + colors perm = [0,1,2] secrets.SystemRandom().shuffle(perm) permuted = {v: perm[coloring[v]] for v in verts} nonces = {v: secrets.token_bytes(16) for v in verts} leaves_hex = [hexf(commit_vertex(v, permuted[v], nonces[v])) for v in verts] merkle_root, levels = build_merkle_tree(leaves_hex) # pick single edge idx = fiat_shamir_select_index(merkle_root, len(edges)) u,v = edges[idx] # prepare openings openings = {} for w in (u,v): openings[w] = { \u0026#34;color\u0026#34;: permuted[w], \u0026#34;nonce\u0026#34;: hexf(nonces[w]), \u0026#34;merkle_proof\u0026#34;: merkle_proof_for_index(levels, w) } proof = { \u0026#34;merkle_root\u0026#34;: merkle_root, \u0026#34;openings\u0026#34;: openings, } return json.dumps(proof) # --- zkPoW verifier --- def zkpow_verify(proof, edges): merkle_root = proof[\u0026#34;merkle_root\u0026#34;] openings = proof[\u0026#34;openings\u0026#34;] # verify Merkle proofs for v_s, opened in openings.items(): v = int(v_s) leaf_hex = hexf(commit_vertex(v, opened[\u0026#34;color\u0026#34;], bytes.fromhex(opened[\u0026#34;nonce\u0026#34;]))) if not verify_merkle_proof(merkle_root, leaf_hex, opened[\u0026#34;merkle_proof\u0026#34;]): print(f\u0026#34;Merkle proof failed for vertex {v}\u0026#34;) return False # recompute chosen edge idx = fiat_shamir_select_index(merkle_root, len(edges)) u,v = map(str, edges[idx]) if u not in openings or v not in openings: print(f\u0026#34;Missing opening for endpoints of edge {idx}\u0026#34;) return False if openings[u][\u0026#34;color\u0026#34;] == openings[v][\u0026#34;color\u0026#34;]: print(f\u0026#34;Edge {idx} endpoints same color -\u0026gt; invalid\u0026#34;) return False return True def main(): print(\u0026#34;==zk-proof-of-work: enabled==\u0026#34;) for i in range(50): print(f\u0026#34;==round {i}==\u0026#34;) edges, n_vertices = make_graph(i * 33 + 10, 0.8) print(json.dumps({\u0026#34;n\u0026#34;: n_vertices, \u0026#34;edges\u0026#34;: edges})) start = time.time() proof = json.loads(input(\u0026#34;proof: \u0026#34;)) end = time.time() if end - start \u0026gt; 5: print(\u0026#34;too slow!\u0026#34;) exit(-1) ok = zkpow_verify(proof, edges) if ok: print(\u0026#34;verified!\u0026#34;) else: print(\u0026#34;failed!\u0026#34;) exit(-1) flag = open(\u0026#34;flag.txt\u0026#34;).read() print(\u0026#34;flag:\u0026#34;, flag) if __name__ == \u0026#34;__main__\u0026#34;: main() Phân tích và lời giải Ở thử thách này, ta không cần phải tô 3 màu cho đồ thị. Hàm verify chỉ kiểm tra hai điểm cuối của một cạnh, và chỉ số cạnh đó là H(merkle_root) % m. Vì ta kiểm soát tất cả các nonce (vì là gốc Merkle) nên có thể thử nonce của một lá cho đến khi thử thách trỏ đến một cạnh có các điểm cuối có màu khác nhau theo bất kỳ màu ngẫu nhiên nào ta chọn. Điều này làm cho mỗi vòng trở nên đơn giản, không cần backtracking mà chỉ cần một vài lần băm.\nSau đây là các bước giải:\nChọn một màu 3 ngẫu nhiên (bất kỳ màu nào cũng được). Xây dựng cây Merkle một lần. Liên tục điều chỉnh nonce của một lá và tính toán lại gốc Merkle theo từng bước (O(log n) mỗi lần thử). Dừng ngay khi H(root) % m chọn một cạnh có màu khác nhau. Gán hai đỉnh đó cho openings 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 # solution.py from pwn import * import json, hashlib, secrets # ===== Challenge-compatible helpers ===== def sha256(b: bytes) -\u0026gt; bytes: return hashlib.sha256(b).digest() def commit_vertex_bytes(v: int, color_label: int, nonce: bytes) -\u0026gt; bytes: # EXACT match to the server\u0026#39;s commit function (but returns raw bytes) return sha256(b\u0026#34;vertex:\u0026#34; + str(v).encode() + b\u0026#34;:\u0026#34; + str(color_label).encode() + b\u0026#34;:\u0026#34; + nonce) def fiat_shamir_select_index(root_hex: str, m: int) -\u0026gt; int: return int.from_bytes(hashlib.sha256(root_hex.encode()).digest(), \u0026#34;big\u0026#34;) % m # ===== Merkle (bytes throughout, then hex only when serializing the proof) ===== def build_merkle_tree_bytes(leaves): \u0026#34;\u0026#34;\u0026#34; leaves: list[bytes] returns: (root_bytes, levels) levels[0] = leaves (bytes) levels[h] = list of bytes at height h \u0026#34;\u0026#34;\u0026#34; if not leaves: z = sha256(b\u0026#34;\u0026#34;) return z, [[z]] levels = [list(leaves)] cur = levels[0] while len(cur) \u0026gt; 1: nxt = [] for i in range(0, len(cur), 2): left = cur[i] right = cur[i+1] if i+1 \u0026lt; len(cur) else left nxt.append(sha256(left + right)) levels.append(nxt) cur = nxt return levels[-1][0], levels def update_leaf_inplace(levels, index, new_leaf): \u0026#34;\u0026#34;\u0026#34; Update levels in place after changing one leaf. O(log n) hashes up to the root, honoring the \u0026#39;duplicate last\u0026#39; rule. \u0026#34;\u0026#34;\u0026#34; levels[0][index] = new_leaf idx = index for h in range(0, len(levels) - 1): level = levels[h] # figure siblings and parent if idx % 2 == 0: right_idx = idx + 1 if idx + 1 \u0026lt; len(level) else idx left = level[idx] right = level[right_idx] parent = sha256(left + right) else: left_idx = idx - 1 left = level[left_idx] right = level[idx] parent = sha256(left + right) # write parent levels[h + 1][idx // 2] = parent idx //= 2 def merkle_proof_for_index(levels, index): \u0026#34;\u0026#34;\u0026#34; Returns proof as list of (sibling_hex, sibling_is_left_bool), exactly like the challenge expects. \u0026#34;\u0026#34;\u0026#34; proof = [] idx = index for level in levels[:-1]: if idx % 2 == 0: sib_index = idx + 1 if idx + 1 \u0026lt; len(level) else idx sibling = level[sib_index] proof.append((sibling.hex(), False)) # sibling on the right else: sib_index = idx - 1 sibling = level[sib_index] proof.append((sibling.hex(), True)) # sibling on the left idx //= 2 return proof # ===== Core: nonce grinding (no coloring solve needed) ===== def build_and_print_proof(graph_line: bytes) -\u0026gt; str: obj = json.loads(graph_line.decode()) n = obj[\u0026#34;n\u0026#34;] edges = obj[\u0026#34;edges\u0026#34;] # list of [u, v] m = len(edges) # 1) Any random 3-coloring works (we only need one good edge per round) rng = secrets.SystemRandom() colors = [rng.randrange(3) for _ in range(n)] # 2) Random nonces for all vertices; build initial tree once nonces = [secrets.token_bytes(16) for _ in range(n)] leaves = [commit_vertex_bytes(v, colors[v], nonces[v]) for v in range(n)] root_bytes, levels = build_merkle_tree_bytes(leaves) # 3) Grind a SINGLE leaf\u0026#39;s nonce until H(root) % m hits a \u0026#34;good\u0026#34; edge pivot = 0 # any index works # Keep a small safety cap; expected tries ~ 1.5 because ~2/3 edges are \u0026#34;good\u0026#34; max_tries = 4096 for _ in range(max_tries): # new nonce for pivot leaf nonces[pivot] = secrets.token_bytes(16) new_leaf = commit_vertex_bytes(pivot, colors[pivot], nonces[pivot]) update_leaf_inplace(levels, pivot, new_leaf) root_hex = levels[-1][0].hex() idx = fiat_shamir_select_index(root_hex, m) u, v = edges[idx] if colors[u] != colors[v]: # 4) Prepare openings for the challenged edge only openings = {} for w in (u, v): openings[str(w)] = { \u0026#34;color\u0026#34;: colors[w], \u0026#34;nonce\u0026#34;: nonces[w].hex(), \u0026#34;merkle_proof\u0026#34;: merkle_proof_for_index(levels, w) } proof = { \u0026#34;merkle_root\u0026#34;: root_hex, \u0026#34;openings\u0026#34;: openings } return json.dumps(proof) # In practice we should never get here; fallback (recolor \u0026amp; retry once) colors = [rng.randrange(3) for _ in range(n)] nonces = [secrets.token_bytes(16) for _ in range(n)] leaves = [commit_vertex_bytes(v, colors[v], nonces[v]) for v in range(n)] root_bytes, levels = build_merkle_tree_bytes(leaves) for _ in range(max_tries): nonces[pivot] = secrets.token_bytes(16) new_leaf = commit_vertex_bytes(pivot, colors[pivot], nonces[pivot]) update_leaf_inplace(levels, pivot, new_leaf) root_hex = levels[-1][0].hex() idx = fiat_shamir_select_index(root_hex, m) u, v = edges[idx] if colors[u] != colors[v]: openings = {} for w in (u, v): openings[str(w)] = { \u0026#34;color\u0026#34;: colors[w], \u0026#34;nonce\u0026#34;: nonces[w].hex(), \u0026#34;merkle_proof\u0026#34;: merkle_proof_for_index(levels, w) } proof = { \u0026#34;merkle_root\u0026#34;: root_hex, \u0026#34;openings\u0026#34;: openings } return json.dumps(proof) # If still unlucky, bail so you can inspect raise RuntimeError(\u0026#34;Grinding failed unexpectedly\u0026#34;) # ===== Runner ===== def main(): context.log_level = \u0026#34;error\u0026#34; # keep pwntools quiet \u0026amp; fast # io = process([\u0026#39;python3\u0026#39;, \u0026#39;zkpow.py\u0026#39;]) io = remote(\u0026#34;zkpow.chal.imaginaryctf.org\u0026#34;, 1337) # banner io.recvline() io.recvline() for i in range(50): io.recvline() # \u0026#34;==round i==\u0026#34; graph_line = io.recvline() # JSON line with n \u0026amp; edges proof = build_and_print_proof(graph_line) io.sendline(proof.encode()) res = io.recvline().decode().strip() # print progress without slowing down print(f\u0026#34;Round {i+1}: {res}\u0026#34;) # flag print(io.recvline().decode().strip()) if __name__ == \u0026#34;__main__\u0026#34;: main() Flag: ictf{zero_knowledge_proof_more_like_i_have_zero_knowledge_of_how_to_prove_this} scalar-division 1 2 # chall.sage assert ((E:=EllipticCurve(GF(0xbde3c425157a83cbe69cee172d27e2ef9c1bd754ff052d4e7e6a26074efcea673eab9438dc45e0786c4ea54a89f9079ddb21),[5,7])).order().factor(limit=2**10)[3][0]*E.lift_x(ZZ(int.from_bytes((flag:=input(\u0026#39;ictf{\u0026#39;)).encode())))).x() == 0x686be42f9c3f431296a928c288145a847364bb259c9f5738270d48a7fba035377cc23b27f69d6ae0fad76d745fab25d504d5 and not print(\u0026#39;\\033[53C\\033[1A}\u0026#39;) Phân tích và lời giải assert kiểm tra: nếu điểm có hoành độ là Q.xy()[0] lift và nhân với k thì nó phải bằng target_x. Tức là assert(k * lift_x(x_Q)).x() == target_x.\nÝ tưởng chính: Nguyên lý dùng ở đây là: nếu thứ tự nhóm điểm của elliptic curve là n và n có một nhân tử là k, thì phép nhân $[k]:P\\rightarrow kP$ không phải là đơn ánh mà nó tồn tại một nhân tử (kernel) thứ bậc k.\nSource If n is a positive integer, we denote by $E(\\mathbb{Q})[n]$ the subgroup of rational points of order dividing n, which is the kernel of the multiplication map from E to itself. https://johncremona.github.io/book/fulltext/chapter3.pdf\nBằng cách dựng $Q = k^{-1} * R$ và sau đó cộng mọi phần tử thuộc kernel (jS), ta thu được nhiều $x_Q$ sao cho khi nhân k vẫn trả về R (tức là target_x).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # solution.py from sage.all import * from Crypto.Util.number import long_to_bytes import string p = 0xbde3c425157a83cbe69cee172d27e2ef9c1bd754ff052d4e7e6a26074efcea673eab9438dc45e0786c4ea54a89f9079ddb21 E = EllipticCurve(GF(p), [5,7]) n = E.order() fac = n.factor(limit=2**10) k = int(fac[3][0]) target_x = 0x686be42f9c3f431296a928c288145a847364bb259c9f5738270d48a7fba035377cc23b27f69d6ae0fad76d745fab25d504d5 m = n // k R = E.lift_x(ZZ(target_x)) k_inv_mod_m = inverse_mod(k, m) Q = k_inv_mod_m * R assert ((E:=EllipticCurve(GF(0xbde3c425157a83cbe69cee172d27e2ef9c1bd754ff052d4e7e6a26074efcea673eab9438dc45e0786c4ea54a89f9079ddb21),[5,7])).order().factor(limit=2**10)[3][0]*E.lift_x(ZZ(Q.xy()[0]))).x() == 0x686be42f9c3f431296a928c288145a847364bb259c9f5738270d48a7fba035377cc23b27f69d6ae0fad76d745fab25d504d5 and not print(\u0026#39;\\033[53C\\033[1A}\u0026#39;) # S được chọn sao cho nhóm con sinh bởi S có kích thước k (tức là kS = O) S = E.lift_x(ZZ(1908615609373310359393680708495309867245478461545179513106385994207950225114719305735749421285909081171302218073610177595)) lst = [] for j in range(k): Pj = Q + j * S x = int(Pj.xy()[0]) b = long_to_bytes(x).decode(\u0026#39;utf-8\u0026#39;, errors=\u0026#39;ignore\u0026#39;) if all(ch in string.printable for ch in b): print(b) Flag: ictf{mayb3_d0nt_m4ke_th3_sca1ar_a_f4ctor_0f_the_ord3r} redacted Phân tích và lời giải Theo lẽ thường, qua phép XOR thì 2 giá trị như nhau sẽ cho ra giá trị 0. Tuy nhiên, ở đây cùng 1 giá trị nhưng lại cho ra 1 output có giá trị khác 0\u0026hellip; Là bởi phần key của phép XOR không phải dạng ASCII mà là dạng hex nên nó sẽ chỉ lấy những giá trị trong hệ thập lục phân.\nỞ đây, phần key của CyberChef dạng hex được lấy theo kiểu sau:\n1 2 3 4 5 6 7 8 9 10 def cyberchef_hexparse(a): h = \u0026#39;\u0026#39; for ch in a: if ch in string.hexdigits: h += ch if \u0026#39; \u0026#39; not in h[-2:]: h += \u0026#39; \u0026#39; else: h += \u0026#39; \u0026#39; return bytes([int(x, 16) for x in h.split()]) Với bài này thì mình thử brute-force và mong rằng độ dài key là nhỏ :3\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # solution.py #!/bin/python import string def cyberchef_hexparse(a): h = \u0026#39;\u0026#39; for ch in a: if ch in string.hexdigits: h += ch if \u0026#39; \u0026#39; not in h[-2:]: h += \u0026#39; \u0026#39; else: h += \u0026#39; \u0026#39; return bytes([int(x, 16) for x in h.split()]) def cyberchef_xor(a, key): return bytes(a[i] ^ key[i % len(key)] for i in range(len(a))) OUTPUT = bytes.fromhex(\u0026#39;656cce6bc175617e5366c952d86c6a536e6ede52df636d7e757fce64d56373\u0026#39;) FLAG_PREFIX = b\u0026#39;ictf{\u0026#39; key_prefix = cyberchef_xor(FLAG_PREFIX, OUTPUT[:len(FLAG_PREFIX)]) for attempt_length in range(len(key_prefix), len(OUTPUT) // 2): print(f\u0026#39;{attempt_length = }\u0026#39;) for attempt in range(256 ** (attempt_length - len(key_prefix))): key = key_prefix + attempt.to_bytes(attempt_length - len(key_prefix)) flag = cyberchef_xor(OUTPUT, key) if flag.isascii() and cyberchef_hexparse(flag.decode()) == key: print(f\u0026#39;Found: {flag}\u0026#39;) exit(0) Flag: ictf{xor_is_bad_bad_encryption} leaky-rsa-revenge chall.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #!/usr/local/bin/python3 import json from Crypto.Util.number import getPrime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from secrets import randbelow, token_bytes from hashlib import sha256 with open(\u0026#39;flag.txt\u0026#39;) as f: flag = f.read() p = getPrime(512) q = getPrime(512) n = p * q e = 65537 d = pow(e, -1, (p-1)*(q-1)) key_m = randbelow(n) key_c = pow(key_m, e, n) key = sha256(str(key_m).encode()).digest()[:16] iv = token_bytes(16) ct = AES.new(key, AES.MODE_CBC, IV=iv).encrypt(pad(flag.encode(), 16)) print(json.dumps({\u0026#39;n\u0026#39;: n, \u0026#39;c\u0026#39;: key_c, \u0026#39;iv\u0026#39;: iv.hex(), \u0026#39;ct\u0026#39;: ct.hex()})) def get_bit(n, k): return (n \u0026gt;\u0026gt; k) % 2 for _ in range(1024): idx = randbelow(4) print(json.dumps({\u0026#39;idx\u0026#39;: idx})) try: response = json.loads(input()) c = response[\u0026#39;c\u0026#39;] % n assert c != key_c m = pow(c, d, n) b = get_bit(m, idx) except (json.JSONDecodeError, TypeError, KeyError, ValueError, AssertionError): b = 2 print(json.dumps({\u0026#39;b\u0026#39;: b})) Phân tích Thử thách này đã sửa lỗi của bài trước bằng cách bỏ phần leak key_m ở cuối. Ta được cung cấp các tham số như sau:\nn: tích của hai số nguyên tố 512 bit p và q e: Khóa công khai, có giá trị bằng 65537 key_c: là khóa key_m sau khi được mã hóa RSA với n và e iv: Là init vector khi mã hóa AES flag bằng khóa là sha256 của key_m ct: Là mã hóa AES của flag. Đề bài cho phép ta gửi lần lượt 1024 số và nhận một trong các bit thứ 0-3 của giải mã RSA của các số đó:\n1 2 3 4 5 6 7 8 9 10 11 12 for _ in range(1024): idx = randbelow(4) print(json.dumps({\u0026#39;idx\u0026#39;: idx})) try: response = json.loads(input()) c = response[\u0026#39;c\u0026#39;] % n assert c != key_c m = pow(c, d, n) b = get_bit(m, idx) except (json.JSONDecodeError, TypeError, KeyError, ValueError, AssertionError): b = 2 print(json.dumps({\u0026#39;b\u0026#39;: b})) =\u0026gt; Ta phải khôi phục lại khóa key_m (từ đây gọi tắt là m) để lấy flag.\nHướng giải Bài này tương tự như tấn công LSB oracle.\nhttps://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack\nĐể tấn công, ta gửi $(2^{e \\times i} \\mod n)*c$ để giải mã và nhận $(((2^i\\mod n) \\times m) \\mod n) \\mod 2$. Để ý rằng $((2^{i+1}\\mod n) \\times m) \\mod n$ bằng $((2^i\\mod n) \\times m) \\mod n$ và trừ cho $0$ hoặc $n$, tùy thuộc vào việc $((2^i\\mod n) \\times m) \\mod n$ lớn hơn hay nhỏ hơn $\\dfrac{n}{2}$. Vì vậy, việc so sánh $(((2^i\\mod n) \\times m) \\mod n) \\mod 2$ và $(((2^{i+1}\\mod n) \\times m) \\mod n) \\mod 2$ cho ta MSB của $(2^i\\mod n) \\times m$. Ở đây, ta nhận được ngẫu nhiên một trong bốn bit thấp.\nĐầu tiên, ta thử các trường hợp cho đến khi ta nhận được $n\\equiv -1 \\mod 16$. Bây giờ, giả sử ta nhận được LSB thứ ba (chỉ số 2, vị trí thứ tư). Ta có thể gửi $(2^{e \\times (i+3)} \\mod n)*c$ và nhận lại $((8\\times (2^i\\mod n) \\times m) \\mod n)$ \u0026amp; 4.\nNhư vậy, $$((8\\times (2^i\\mod n) \\times m) \\mod n) \u0026 4 =int((((8\\times (2^i\\mod n) \\times m) \\mod n)\\mod 8) \\ge 4)$$ và giá trị $((8\\times (2^i\\mod n) \\times m) \\mod n)\\mod 8$ là bit đúng sai của đẳng thức $$0-n\\times \\lfloor\\dfrac{(8\\times (2^i\\mod n) \\times m)}{n}\\rfloor\\mod 8 =\\lfloor\\dfrac{(8\\times (2^i\\mod n) \\times m)}{n}\\rfloor\\mod 8$$Giá trị này cho chúng ta biết $(2^i \\mod n) \\times m$ nằm trong khoảng nào trong số các khoảng $[0, n/8), \u0026hellip;, [7*n/8, n)$, nhưng chúng ta chỉ nhận được MSB của nó (từ $\\ge 4$ hoặc \u0026amp; 4), vì vậy về cơ bản chúng ta chỉ nhận được một MSG của $(2^i \\mod n) \\times m$. Lặp lại điều này sẽ cho phép chúng ta thu được toàn bộ m.\nVề bản chất, phương pháp này là binary-search trên phần fractional m/n: mỗi bit thu được sẽ cho ta cắt đôi khoảng hiện tại (giống LSB-oracle). Dùng việc hỏi “bit của octant” là một biến thể nhưng về lượng thông tin mỗi truy vấn vẫn ~1 bit, do đó độ phức tạp tương đương LSB-oracle cơ bản.\nSau đây là phần code giải:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 # get_key_m.py from fractions import Fraction from pwn import * import json # context.log_level = \u0026#39;debug\u0026#39; def get_data(): # target = process([\u0026#34;python3\u0026#34;, \u0026#34;chall.py\u0026#34;]) target = remote(\u0026#39;leaky-rsa-revenge.chal.imaginaryctf.org\u0026#39;, 1337) target.recvline() data = target.recvline() params = json.loads(data) c = int(params[\u0026#39;c\u0026#39;]) n = int(params[\u0026#39;n\u0026#39;]) iv = params[\u0026#39;iv\u0026#39;] ct = params[\u0026#39;ct\u0026#39;] e = 65537 return target, n, e, c, iv, ct target, n, e, c, iv, ct = get_data() while n \u0026amp; 0xf != 0xf: target.close() target, n, e, c, iv, ct = get_data() open(\u0026#34;ct.hex\u0026#34;, \u0026#34;w\u0026#34;).write(json.dumps({\u0026#39;iv\u0026#39;: iv, \u0026#39;ct\u0026#39;: ct})) print(\u0026#34;n:\u0026#34;, n) print(\u0026#34;c:\u0026#34;, c) low, high = Fraction(0), Fraction(n) for _ in range(n.bit_length()): x = json.loads(target.recvline())[\u0026#39;idx\u0026#39;] print(\u0026#34;----------------------\u0026#34;) print(f\u0026#34;Round {_}, idx: {x}\u0026#34;) c_i = c * pow(2**(_+1+x), e, n)% n target.sendline(json.dumps({\u0026#39;c\u0026#39;: c_i})) parity = json.loads(target.recvline())[\u0026#39;b\u0026#39;] print(\u0026#34;parity:\u0026#34;, parity) mid = (low + high) / 2 if parity == 0: high = mid else: low = mid if high - low \u0026lt;= Fraction(1, n): break print(f\u0026#34;low: {int(low)}\u0026#34;) print(f\u0026#34;high: {int(high)}\u0026#34;) print(f\u0026#34;high - low: {int(high - low)}\u0026#34;) print(int(high)) 1 2 3 4 5 6 7 8 9 10 11 12 13 # get_flag.py from Crypto.Cipher import AES from Crypto.Util.Padding import unpad from hashlib import sha256 import json with open(\u0026#34;ct.hex\u0026#34;, \u0026#34;r\u0026#34;) as f: data = json.loads(f.read()) iv, ct = bytes.fromhex(data[\u0026#34;iv\u0026#34;]), bytes.fromhex(data[\u0026#34;ct\u0026#34;]) # copy key_m from the result key_m = 66913879129427921532141095805213088350786068884711371183610467808888726432628555235077071240182816868700010352314530781554928879532699339797452869208244793928847297090122325104212375055788476001149144065203543329623887717342649312948304461426083404294042817825376050063313290113639594521177002093126711190702 key = sha256(str(key_m).encode()).digest()[:16] flag = unpad(AES.new(key, AES.MODE_CBC, IV=iv).decrypt(ct), 16).decode() print(flag) Flag: ictf{p13cin9_7h3_b1t5_t0g37her_7d092f5d43ebbf6fa60fba8c9e9ac4466daba9a71d04def7e5bf09bcce5649c8} clcg chall.py\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from Crypto.Util.number import getPrime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from secrets import randbelow, token_bytes import json with open(\u0026#39;flag.txt\u0026#39;) as f: flag = f.read().strip() class CLCG: def __init__(self, length): self.p = getPrime(256) self.A = [randbelow(self.p) for _ in range(length)] self.C = [randbelow(self.p) for _ in range(length)] self.X = [randbelow(self.p) for _ in range(length)] def rand(self): self.X = [(a * x + c) % self.p for a, x, c in zip(self.A, self.X, self.C)] return int.to_bytes((sum(self.X) % self.p) \u0026gt;\u0026gt; 192, 8) NUM_HINTS = 36 clcg = CLCG(8) data = dict() data[\u0026#39;p\u0026#39;] = clcg.p data[\u0026#39;A\u0026#39;] = clcg.A data[\u0026#39;hints\u0026#39;] = [clcg.rand().hex() for _ in range(NUM_HINTS)] key = clcg.rand() + clcg.rand() iv = token_bytes(16) cipher = AES.new(key, AES.MODE_CBC, iv=iv) data[\u0026#39;iv\u0026#39;] = iv.hex() data[\u0026#39;ct\u0026#39;] = cipher.encrypt(pad(flag.encode(), 16)).hex() print(json.dumps(data)) Phân tích đề bài p, A, C, X lần luợt là số nguyên tố 256 bit và các list gồm 1 độ dài nhất định (theo đề là 8) các giá trị ngẫu nhiên bé hơn p. Hàm rand() cho đầu ra là top 64 bit đầu của tổng S là 8 giá trị LCG không phụ thuộc modulo p của các cặp (A, X, C) tương ứng và gán X mới lần lượt là 8 giá trị LCG này. $$X^{(i)}_{t+1}\\equiv a_i\\times X^{(i)}_t+c_i\\mod p,i=[1, 8]$$ $$S =\\displaystyle \\sum_{i=1}^8 X_t^{(i)}\\mod p$$ Lấy hàm rand() 36 lần rồi lấy 2 lần tiếp theo làm key cho chế độ mã hóa AES mode CBC với iv là ngẫu nhiên và plaintext là flag. 1 2 3 4 5 data[\u0026#39;hints\u0026#39;] = [clcg.rand().hex() for _ in range(36)] key = clcg.rand() + clcg.rand() iv = token_bytes(16) cipher = AES.new(key, AES.MODE_CBC, iv=iv) Hướng giải Hint from admin\nNote that if x1 = a*x0 + c then x1 + c/(a-1) = a*x0 + ac/(a-1) = a(x0 + c/(a-1)) so xi = C*a**i - c/(a-1). If we add up 8 LCGs, it will be of the form sum(Cj*aj**i for j) - D, and taking the partial differences gets rid of D. We now note that this satisfies the linear recurrence whose characteristic polynomial is prod(x - aj for j). We use this recurrence to build a lattice that will be 0 mod p when multiplied by the vector of true differences between state sums.\nKhai thác từ LCG cho trước Từ phép biến đổi affine LCG ta sẽ thử tạo chuỗi cấp số và trình bày công thức. Giả sử, tồn tại $k$ sao cho: $$X^{(i)}_{t+1} + k\\equiv a_i\\times (X^{(i)}_t+k)\\mod p,i=[1, 8]$$$$\\Leftrightarrow (a_i-1)\\times k\\equiv c\\mod p,i=[1, 8]\\Leftrightarrow k\\equiv \\dfrac{c}{a_i-1}\\mod p,i=[1, 8]$$Như vậy, ta hoàn toàn có thể biến đổi dãy trên thành dãy số hệ số nhân $$C^{(i)}_{t+1}\\equiv a_i\\times C^{(i)}_t\\mod p,i=[1, 8]$$, với $C_i = X_i+\\dfrac{c}{a_i-1}\\mod p,i=[1, 8]$\nDo đó, tổng S biến đổi thành:\n$$S\\equiv \\displaystyle \\sum_{j=1}^8 K_ja^i_j-D\\mod p$$ Có nghĩa là nếu ta lấy từng cặp hiệu của S đôi một liên tiếp thì nó sẽ khử D ($\\Delta S_i=S_{i+1}-S_i$), để lại tổng của các thừa số thỏa mãn hồi quy tuyến tính bậc 8 với đa thức đặc trưng là: $$m(x)=\\displaystyle \\prod_{j=1}^8(x-a_j)\\in \\mathbb{F}_p[x]$$Khôi phục lại $\\Delta S_t$ Theo đề bài, ta sẽ tách $\\Delta S_t$ thành $2^{192}\\Delta b_t+d_t$ với $d_t\\in (-2^{192}, 2^{192})$\nTừ phép hồi quy trên, suy ra được: $$\\displaystyle \\sum_{k=0}^8c_k\\Delta S_{t+k}\\equiv 0 \\mod p\\ \\ (1)$$Vì vậy, khi ta sử dụng phép tách trên, $(1)$ sẽ trở thành phương trình đồng dư tuyến tính modulo p với ẩn $d_t$\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from Crypto.Cipher import AES from sage.all import * import json with open(\u0026#34;out.txt\u0026#34;) as f: out = json.load(f) p = out[\u0026#34;p\u0026#34;] A = out[\u0026#34;A\u0026#34;] hints = [int(hint, 16) for hint in out[\u0026#34;hints\u0026#34;]] last = hints[-1] \u0026lt;\u0026lt; 192 hints = [hints[i + 1] - hints[i] for i in range(len(hints) - 1)] ct = bytes.fromhex(out[\u0026#34;ct\u0026#34;]) iv = bytes.fromhex(out[\u0026#34;iv\u0026#34;]) def decrypt(rand1, rand2): cipher = AES.new( int.to_bytes(rand1, 8) + int.to_bytes(rand2, 8), AES.MODE_CBC, iv=iv ) return cipher.decrypt(ct) x = PolynomialRing(GF(p), \u0026#34;x\u0026#34;).gen() rec = list(map(int, prod(x - a for a in A))) L = [ [0 for _ in range(i)] + rec + [0 for _ in range(len(hints) - len(rec) - i)] for i in range(len(hints) - len(rec) + 1) ] + [[p * int(i == j) for j in range(len(hints))] for i in range(len(rec) - 1)] L = Matrix(ZZ, L) B = L.LLL() yprime = (2**192) * vector(ZZ, hints) Byprime = B * yprime v = vector(ZZ, [round(i / p) for i in Byprime]) Bzprime = v * p - Byprime zprime = (B ** (-1)) * Bzprime # print([len(bin(i)) for i in zprime]) - debug - should be around 192 xprime = list(yprime + zprime) for _ in range(2): xprime.append((-vector(rec[:-1]) * vector(xprime[-len(rec) + 1 :])) % p) rand1 = ((last + xprime[-2]) % p) \u0026gt;\u0026gt; 192 rand2 = ((last + xprime[-2] + xprime[-1]) % p) \u0026gt;\u0026gt; 192 for r1 in range(rand1 - 4, rand1 + 4): for r2 in range(rand2 - 4, rand2 + 4): flag = decrypt(r1, r2) if b\u0026#34;ictf\u0026#34; in flag: print(flag) Flag: ictf{y3t_an07h3r_lcg_ch411_7b24ac314588057bfd4b70b10585a277} Bigger-RSA bigger_rsa.sage\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from Crypto.Util.number import getPrime, bytes_to_long import secrets n = 32 e = 0x10001 N = 64 flag = b\u0026#39;ictf{REDACTED}\u0026#39; flag = secrets.token_bytes((n * 63) - len(flag)) + flag ps = [getPrime(512) for _ in range(n)] m = 1 for i in ps: m *= i nums = [CRT([1 + secrets.randbits(260) for _ in range(n)],ps) for __ in range(N)] ct = pow(bytes_to_long(flag),e,m) print(f\u0026#34;ct={ct}\u0026#34;) print(f\u0026#34;m={m}\u0026#34;) print(f\u0026#34;nums={nums}\u0026#34;) Tài liệu (scalar-division): https://johncremona.github.io/book/fulltext/chapter3.pdf (zkpow): https://en.wikipedia.org/wiki/Merkle_tree https://en.wikipedia.org/wiki/Zero-knowledge_proof https://blog.codeminer42.com/zero-knowledge-proofs-and-merkle-trees-an-overview-before-diving-into-it/ (leaky-rsa-revenge): https://crypto.stackexchange.com/questions/11053/rsa-least-significant-bit-oracle-attack (clcg): https://en.wikipedia.org/wiki/Linear_congruential_generator https://crypto.stackexchange.com/questions/2086/predicting-values-from-a-linear-congruential-generator ","date":"2025-09-14T14:17:02+07:00","image":"https://r1muru2006.github.io/p/imaginaryctf-2025/imaginary_hu_9bac1ba50f7d6e7.jpg","permalink":"https://r1muru2006.github.io/p/imaginaryctf-2025/","title":"ImaginaryCTF 2025"},{"content":"Crypto 1. Cs2RTrash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # chall.py from Crypto.Util.number import bytes_to_long, long_to_bytes import random e = 65537 n1 = 106274132069853085771962684070654057294853035674691451636354054913790308627721 n2 = 73202720518342632558813895439681594395095017145510800999002057461861058762579 n3 = 58129476807669651703262865829974447479957080526429581698674448004236654958847 message = b\u0026#39;HOLACTF{...}\u0026#39; m = bytes_to_long(message) c1 = pow(m, e, n1) c2 = pow(m, e, n2) c3 = pow(m, e, n3) print(f\u0026#34;c1: {c1}\u0026#34;) print(f\u0026#34;c2: {c2}\u0026#34;) print(f\u0026#34;c3: {c3}\u0026#34;) 1 2 3 4 // output.txt c1: 40409669713698525444927116587938485167766997176959778633087672968720888190012 c2: 50418608792183022472533104230595523000246213655735834753443442906871618770832 c3: 7151799367443802424297049002310776844321501905398348074481144597918413565153 Đây chỉ là 1 bài RSA đơn giản và mình để ý rằng n1 là số nguyên tố nên bài này có thể được giải như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # solution.py from Crypto.Util.number import inverse, long_to_bytes e = 65537 n1 = 106274132069853085771962684070654057294853035674691451636354054913790308627721 n2 = 73202720518342632558813895439681594395095017145510800999002057461861058762579 n3 = 58129476807669651703262865829974447479957080526429581698674448004236654958847 c1 = 40409669713698525444927116587938485167766997176959778633087672968720888190012 c2 = 50418608792183022472533104230595523000246213655735834753443442906871618770832 c3 = 7151799367443802424297049002310776844321501905398348074481144597918413565153 d1 = inverse(e, n1 - 1) x = pow(c1, d1, n1) print(long_to_bytes(x)) Flag: HOLACTF{ju5t_a_b4s1c_CRT} 2. EnigmaHardCode 1 2 // attachment SWWSAOL{CRK_NTX_AGBXRRLNYQC_ANGQBQHR_TY_QNZ_PPLNFBFXX} Ban đầu mình không biết cuộn tròn xuống là có reflector với plugboard nên đã bỏ qua :333 Khi phát hiện ra thì mình liên kết lại các dữ liệu đã có và tìm được trang wiki có để thiết lập enigma machine Vì đã biết rotor order, reflector, ring settings và chỉ còn thiếu 1 cặp plugboard nên mình đã brute-force các cặp còn lại đến khi tìm ra flag format phù hợp như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 # solution.py import string, re, time from itertools import combinations from multiprocessing import Pool, cpu_count ALPHA = string.ascii_uppercase pattern = re.compile(r\u0026#34;HOLACTF\\{.*\\}\u0026#34;) # Machine parameters (use your exact ones) ROTOR = { \u0026#34;I\u0026#34;: (\u0026#34;EKMFLGDQVZNTOWYHXUSPAIBRCJ\u0026#34;, \u0026#34;Q\u0026#34;), \u0026#34;II\u0026#34;: (\u0026#34;AJDKSIRUXBLHWTMCQGZNPYFVOE\u0026#34;, \u0026#34;E\u0026#34;), \u0026#34;III\u0026#34;: (\u0026#34;BDFHJLCPRTXVZNYEIWGAKMUSQO\u0026#34;, \u0026#34;V\u0026#34;), } REFLECTOR_C = \u0026#34;FVPJIAOYEDRZXWGCTKUQSBNMHL\u0026#34; ORDER = (\u0026#34;II\u0026#34;, \u0026#34;III\u0026#34;, \u0026#34;I\u0026#34;) RING = {\u0026#34;II\u0026#34;: 4, \u0026#34;III\u0026#34;: 7, \u0026#34;I\u0026#34;: 2} # use exactly what you intend PLUG_KNOWN = [\u0026#34;AO\u0026#34;, \u0026#34;DP\u0026#34;, \u0026#34;ER\u0026#34;, \u0026#34;FT\u0026#34;, \u0026#34;IU\u0026#34;, \u0026#34;JW\u0026#34;, \u0026#34;KZ\u0026#34;, \u0026#34;MX\u0026#34;] MISSING_POOL = list(\u0026#34;BCGHLNQSVY\u0026#34;) CIPH = \u0026#34;SWWSAOL{CRK_NTX_AGBXRRLNYQC_ANGQBQHR_TY_QNZ_PPLNFBFXX}\u0026#34; # Precompute rotor inverse maps def inv_map(w): r = [\u0026#34;?\u0026#34;] * 26 for i, c in enumerate(w): r[ord(c) - 65] = ALPHA[i] return \u0026#34;\u0026#34;.join(r) L, M, R = ORDER LW, Lnot = ROTOR[L] MW, Mnot = ROTOR[M] RW, Rnot = ROTOR[R] LI = inv_map(LW) MI = inv_map(MW) RI = inv_map(RW) rL, rM, rR = RING[L] - 1, RING[M] - 1, RING[R] - 1 # fast decrypt function for one pos/pair def decrypt_with(pos, extra_pair): # Build plug mapping as a list for fast int ops pmap = list(range(26)) for pair in PLUG_KNOWN + ([extra_pair] if extra_pair else []): a = pair[0] b = pair[1] ai = ord(a) - 65 bi = ord(b) - 65 pmap[ai] = bi pmap[bi] = ai pL, pM, pR = [ord(c) - 65 for c in pos] out_chars = [] for ch in CIPH: if ch not in ALPHA: out_chars.append(ch) continue # stepping (double-step behavior) if ALPHA[pM] == Mnot: pM = (pM + 1) % 26 pL = (pL + 1) % 26 if ALPHA[pR] == Rnot: pM = (pM + 1) % 26 pR = (pR + 1) % 26 # plugboard in x = pmap[ord(ch) - 65] # forward through right, mid, left (account ringoffsets) def forward(w, x, p, r): idx = (x + p - r) % 26 return (ord(w[idx]) - 65 - p + r) % 26 x = forward(RW, x, pR, rR) x = forward(MW, x, pM, rM) x = forward(LW, x, pL, rL) # reflector x = ord(REFLECTOR_C[x]) - 65 # back through left,middle,right (inverse maps) def back(iw, x, p, r): idx = (x + p - r) % 26 return (ord(iw[idx]) - 65 - p + r) % 26 x = back(LI, x, pL, rL) x = back(MI, x, pM, rM) x = back(RI, x, pR, rR) # plugboard out out_chars.append(chr(pmap[x] + 65)) return \u0026#34;\u0026#34;.join(out_chars) # Worker: given a pair (like \u0026#34;BC\u0026#34;), test all positions and return any matches def worker_for_pair(pair): found = [] pair = \u0026#34;\u0026#34;.join(pair) for a in ALPHA: for b in ALPHA: for c in ALPHA: pos = a + b + c pt = decrypt_with(pos, pair) if pattern.search(pt): found.append((pair, pos, pt)) return found def main(): pairs = list(combinations(MISSING_POOL, 2)) print(\u0026#34;Total pairs:\u0026#34;, len(pairs)) nproc = max(1, cpu_count() - 0) print(\u0026#34;Using processes:\u0026#34;, nproc) start = time.time() with Pool(nproc) as pool: # map worker across pairs; each worker tests all 26^3 positions for that pair results = pool.map(worker_for_pair, pairs) elapsed = time.time() - start matches = [m for sub in results for m in sub] print(\u0026#34;Elapsed:\u0026#34;, elapsed, \u0026#34;seconds\u0026#34;) print(\u0026#34;Matches found:\u0026#34;, len(matches)) for pair, pos, pt in matches: print(\u0026#34;pair\u0026#34;, pair, \u0026#34;pos\u0026#34;, pos, \u0026#34;-\u0026gt;\u0026#34;, pt) if __name__ == \u0026#34;__main__\u0026#34;: main() Kết quả trả về:\n1 2 3 4 5 Total pairs: 45 Using processes: 12 Elapsed: 7.59969425201416 seconds Matches found: 1 pair CV pos ULW -\u0026gt; HOLACTF{WAR_DIE_GEHEIMHISSE_WIRKLICH_SO_GUT_VERSTECKP} Tuy nhiên, flag này vẫn chưa chính xác nên mình đã hỏi chatGPT thử thì nhận được prompt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 ... Check adjacent starting positions: Often the crib falls into place if the initial rotor position is shifted by 1–2 steps. Try decrypting again with positions just before and after ULW (e.g., ULV, ULX, UKW, etc.). Double-check ring settings vs. rotor positions: Sometimes code mixes up Ringstellung (internal offset) with Grundstellung (daily key start). If those were off, letters will be slightly wrong throughout. Test all 45 possible plugboard completions again but only around ULW neighborhood (like ±5 positions). That should be much faster. Language filter: Since the plaintext is clearly German, you can filter candidates through a simple dictionary check (look for \u0026#34;GEHEIMNISSE\u0026#34; and \u0026#34;VERSTECKT\u0026#34;). 👉 I think the true flag should be: HOLACTF{WAR_DIE_GEHEIMNISSE_WIRKLICH_SO_GUT_VERSTECKT} Submit thử thì nhận được kết quả trả về đúng.\nFlag: HOLACTF{WAR_DIE_GEHEIMNISSE_WIRKLICH_SO_GUT_VERSTECKT} 3. ImLosingYou 1 2 3 4 5 6 7 8 9 10 11 12 13 # encrypt.py from random import getrandbits, FLAG from Crypto.Util.number import * e = 2 n = getPrime(256) * getPrime(256) m = bytes_to_long(FLAG) mod_m = m - getrandbits(80) c = pow(m, 2, n) print(f\u0026#34;n = {n}\u0026#34;) print(f\u0026#34;c = {c}\u0026#34;) print(f\u0026#34;mod_m = {mod_m}\u0026#34;) 1 2 3 n = 5655306554322573090396099186606396534230961323765470852969315242956396512318053585607579359989407371627321079880719083136343885009234351073645372666488587 c = 249064480176144876250402041707185886135379496538171928784862949393878232927200977890895568473400681389529997203697206006850790029940405682934025 mod_m = 499063603337435213780295973826237775412685978121823376141602090122856806 Mình giả sử FLAG có độ dài ngắn và thử lấy căn của c thì đúng là như vậy:\n1 2 3 4 5 6 7 8 9 # solution.py from Crypto.Util.number import long_to_bytes from gmpy2 import iroot n = 5655306554322573090396099186606396534230961323765470852969315242956396512318053585607579359989407371627321079880719083136343885009234351073645372666488587 c = 249064480176144876250402041707185886135379496538171928784862949393878232927200977890895568473400681389529997203697206006850790029940405682934025 mod_m = 499063603337435213780295973826237775412685978121823376141602090122856806 pt = iroot(c, 2)[0] print(long_to_bytes(pt)) Flag: HOLACTF{f33ls_l1k3_l0s1ng_h3r} Misc 1. LunaDB 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 // main.rs use std::fs::{File, OpenOptions}; use std::io::{self, Read, Write, BufRead, Cursor, Seek, SeekFrom}; use std::path::Path; use std::env; use std::process; use std::time::{SystemTime, UNIX_EPOCH}; use rand::{Rng, thread_rng}; use rand::distributions::Alphanumeric; use openssl::symm::{Cipher, Crypter, Mode}; use hex_literal::hex; use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt}; use leb128; const H_START: [u8; 4] = hex!(\u0026#34;FF1337FF\u0026#34;); const H_END: [u8; 4] = hex!(\u0026#34;FFCAFEFF\u0026#34;); const D_START: [u8; 4] = hex!(\u0026#34;FF7270FF\u0026#34;); const D_END: [u8; 4] = hex!(\u0026#34;FFEDEDFF\u0026#34;); const F_START: [u8; 4] = hex!(\u0026#34;FFDEADFF\u0026#34;); const F_END: [u8; 4] = hex!(\u0026#34;FFBEEFFF\u0026#34;); const SIG: [u8; 4] = hex!(\u0026#34;4C554E41\u0026#34;); enum DbMode\u0026lt;\u0026#39;a\u0026gt; { Append { existing: \u0026amp;\u0026#39;a [[u8; 8]] }, Create, } fn find_pattern(data: \u0026amp;[u8], pattern: \u0026amp;[u8]) -\u0026gt; Option\u0026lt;usize\u0026gt; { data.windows(pattern.len()).position(|w| w == pattern) } fn get_input(prompt_text: \u0026amp;str) -\u0026gt; io::Result\u0026lt;String\u0026gt; { print!(\u0026#34;{}\u0026#34;, prompt_text); io::stdout().flush()?; let stdin = io::stdin(); let mut line = String::new(); stdin.lock().read_line(\u0026amp;mut line)?; Ok(line.trim().to_string()) } ... fn main() -\u0026gt; io::Result\u0026lt;()\u0026gt; { let args: Vec\u0026lt;String\u0026gt; = env::args().collect(); if args.len() != 2 { eprintln!(\u0026#34;Usage: {} \u0026lt;lunadb_file\u0026gt;\u0026#34;, args[0]); process::exit(1); } let db_path = Path::new(\u0026amp;args[1]); let num_notes_to_create: usize = loop { match get_input(\u0026#34;How many notes do you want to create? \u0026#34;)?.parse() { Ok(n) if n \u0026gt; 0 =\u0026gt; break n, _ =\u0026gt; println!(\u0026#34;Please enter a valid positive number.\u0026#34;), } }; if db_path.exists() { let mut f = Vec::new(); File::open(\u0026amp;db_path)?.read_to_end(\u0026amp;mut f)?; let keys = { let start = find_pattern(\u0026amp;f, \u0026amp;F_START).unwrap() + F_START.len(); let end = find_pattern(\u0026amp;f, \u0026amp;F_END).unwrap(); (\u0026amp;f[start..end]).chunks_exact(8) .map(|c| c.try_into().unwrap()) .collect::\u0026lt;Vec\u0026lt;[u8;8]\u0026gt;\u0026gt;() }; let next_id = get_next_id(\u0026amp;f)?; let (notes, _, _) = build(DbMode::Append { existing: \u0026amp;keys }, num_notes_to_create, next_id)?; write_db(\u0026amp;db_path, None, Some(\u0026amp;f), \u0026amp;notes, \u0026amp;[])?; println!(\u0026#34;Appended {} notes\u0026#34;, num_notes_to_create); } else { let header = Header { db_name: get_input(\u0026#34;Database Name: \u0026#34;)?, reg_name: get_input(\u0026#34;Registered Name: \u0026#34;)?, license_key: get_input(\u0026#34;License Key: \u0026#34;)?.into_bytes(), }; let (notes, keys, _) = build(DbMode::Create, num_notes_to_create, 1)?; write_db(\u0026amp;db_path, Some(header), None, \u0026amp;notes, \u0026amp;keys)?; println!(\u0026#34;Created new DB with {} notes\u0026#34;, num_notes_to_create); } Ok(()) } Đề cho ta hai tệp main.rs và secret.lunadb, với yêu cầu đọc tệp secret. Từ main.rs thì mình biết được rằng:\nGhi chú được mã hóa bằng DES-ECB Key được lưu trữ trong phần F_START..F_END (khối 8-bytes) Mỗi ghi chú có một key_index_field. Mảng string/byte sử dụng tùy chỉnh tag + LEB128 length + data format. Sau đó, mình nhờ chatGPT tạo ra 1 cái decryptor thỏa mãn và dừng khi thấy flag format:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 # solution.py import struct from io import BytesIO from Crypto.Cipher import DES # ---- Constants (magic markers) ---- H_START = bytes.fromhex(\u0026#34;FF1337FF\u0026#34;) H_END = bytes.fromhex(\u0026#34;FFCAFEFF\u0026#34;) D_START = bytes.fromhex(\u0026#34;FF7270FF\u0026#34;) D_END = bytes.fromhex(\u0026#34;FFEDEDFF\u0026#34;) F_START = bytes.fromhex(\u0026#34;FFDEADFF\u0026#34;) F_END = bytes.fromhex(\u0026#34;FFBEEFFF\u0026#34;) SIG = b\u0026#34;LUNA\u0026#34; # ---- Helpers ---- def find_pattern(data: bytes, pattern: bytes) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;Find pattern inside data and return its position.\u0026#34;\u0026#34;\u0026#34; pos = data.find(pattern) if pos == -1: raise ValueError(f\u0026#34;Pattern {pattern.hex()} not found\u0026#34;) return pos def read_uleb128(f: BytesIO) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;Read unsigned LEB128 integer.\u0026#34;\u0026#34;\u0026#34; result, shift = 0, 0 while True: b = f.read(1) if not b: raise EOFError(\u0026#34;Unexpected EOF in LEB128\u0026#34;) b = b[0] result |= (b \u0026amp; 0x7F) \u0026lt;\u0026lt; shift if (b \u0026amp; 0x80) == 0: break shift += 7 return result def read_string(f: BytesIO) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34;Read custom encoded string (flag + LEB128 + data).\u0026#34;\u0026#34;\u0026#34; flag = f.read(1) if not flag: raise EOFError(\u0026#34;Unexpected EOF reading string\u0026#34;) flag = flag[0] if flag == 0x00: return \u0026#34;\u0026#34; elif flag == 0x0b: length = read_uleb128(f) return f.read(length).decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;replace\u0026#34;) elif flag == 0x0c: length = read_uleb128(f) return f.read(length).decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;replace\u0026#34;) else: raise ValueError(f\u0026#34;Invalid string flag {flag:#x}\u0026#34;) def read_bytes(f: BytesIO) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Read custom encoded byte string.\u0026#34;\u0026#34;\u0026#34; flag = f.read(1) if not flag: raise EOFError(\u0026#34;Unexpected EOF reading bytes\u0026#34;) flag = flag[0] if flag == 0x00: return b\u0026#34;\u0026#34; elif flag == 0x0c: length = read_uleb128(f) return f.read(length) elif flag == 0x0b: length = read_uleb128(f) return f.read(length) else: raise ValueError(f\u0026#34;Invalid byte flag {flag:#x}\u0026#34;) def des_decrypt(key: bytes, data: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Decrypt DES-ECB with padding removal.\u0026#34;\u0026#34;\u0026#34; cipher = DES.new(key, DES.MODE_ECB) pt = cipher.decrypt(data) padlen = pt[-1] if 1 \u0026lt;= padlen \u0026lt;= 8 and pt.endswith(bytes([padlen])*padlen): pt = pt[:-padlen] return pt # ---- Main LunaDB Parser ---- def parse_lunadb(filename: str): with open(filename, \u0026#34;rb\u0026#34;) as f: data = f.read() # Validate if not data.startswith(SIG): raise ValueError(\u0026#34;Not a valid LunaDB file\u0026#34;) # Extract sections d_start = find_pattern(data, D_START) + len(D_START) d_end = find_pattern(data, D_END) f_start = find_pattern(data, F_START) + len(F_START) f_end = find_pattern(data, F_END) notes_section = data[d_start:d_end] keys_section = data[f_start:f_end] # Parse keys keys = [keys_section[i:i+8] for i in range(0, len(keys_section), 8)] # Parse notes fnotes = BytesIO(notes_section) notes = [] while fnotes.tell() \u0026lt; len(notes_section): try: note_id = struct.unpack(\u0026#34;\u0026lt;H\u0026#34;, fnotes.read(2))[0] except: break access_token = read_string(fnotes) first_name = read_string(fnotes) last_name = read_string(fnotes) email = read_string(fnotes) title = read_string(fnotes) key_index_field = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, fnotes.read(8))[0] encrypted_content = read_bytes(fnotes) creation_date = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, fnotes.read(8))[0] modification_date = struct.unpack(\u0026#34;\u0026lt;Q\u0026#34;, fnotes.read(8))[0] suspended = struct.unpack(\u0026#34;\u0026lt;B\u0026#34;, fnotes.read(1))[0] # Which key was used? plaintext = None if key_index_field != 0xFFFFFFFFFFFFFFFF: for idx in range(64): if key_index_field \u0026amp; (1 \u0026lt;\u0026lt; idx): if idx \u0026lt; len(keys): try: plaintext = des_decrypt(keys[idx], encrypted_content).decode(\u0026#34;utf-8\u0026#34;, errors=\u0026#34;replace\u0026#34;) except Exception as e: plaintext = f\u0026#34;\u0026lt;decrypt error: {e}\u0026gt;\u0026#34; break else: plaintext = \u0026#34;\u0026lt;no content\u0026gt;\u0026#34; notes.append({ \u0026#34;id\u0026#34;: note_id, \u0026#34;title\u0026#34;: title, \u0026#34;author\u0026#34;: f\u0026#34;{first_name} {last_name}\u0026#34;, \u0026#34;email\u0026#34;: email, \u0026#34;content\u0026#34;: plaintext, \u0026#34;suspended\u0026#34;: suspended, \u0026#34;access_token\u0026#34;: access_token, }) return notes # ---- Run ---- if __name__ == \u0026#34;__main__\u0026#34;: import sys, json if len(sys.argv) != 2: print(f\u0026#34;Usage: {sys.argv[0]} \u0026lt;lunadb_file\u0026gt;\u0026#34;) sys.exit(1) notes = parse_lunadb(sys.argv[1]) for n in notes: print(\u0026#34;=\u0026#34;*40) print(f\u0026#34;Note ID: {n[\u0026#39;id\u0026#39;]}\u0026#34;) print(f\u0026#34;Title: {n[\u0026#39;title\u0026#39;]}\u0026#34;) print(f\u0026#34;Author: {n[\u0026#39;author\u0026#39;]} \u0026lt;{n[\u0026#39;email\u0026#39;]}\u0026gt;\u0026#34;) print(f\u0026#34;Access Token: {n[\u0026#39;access_token\u0026#39;]}\u0026#34;) print(f\u0026#34;Suspended: {n[\u0026#39;suspended\u0026#39;]}\u0026#34;) print(f\u0026#34;Content:\\n{n[\u0026#39;content\u0026#39;]}\u0026#34;) if \u0026#34;HOLACTF{\u0026#34; in n[\u0026#39;content\u0026#39;]: break Kết quả trả về:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ... Note ID: 2976 Title: coding Author: Candice Debroux \u0026lt;Candice_Debroux@gmx.com\u0026gt; Access Token: 7zVjVolwo0ZOXwnbexQEx7YsxyelEekQ Suspended: 0 Content: Programming today is a race between software engineers striving to build bigger and better idiot-proof programs and the Universe trying to produce bigger and better idiots. So far, the Universe is winning. ======================================== Note ID: 7272 Title: This is real flag Author: lunaere the secret agent \u0026lt;luna@osu.me\u0026gt; Access Token: ZEBD9aJy8iMuGBqUaa1yUKoXvddvGLra Suspended: 1 Content: HOLACTF{4_c0Ol_Cu5t0m_f1lE_5truC7} Flag: HOLACTF{4_c0Ol_Cu5t0m_f1lE_5truC7} 2. Weird PNG Đề cho ta một file weird.png và khi phân tích, ta được:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ➜ build git:(master) ✗ xxd weird.png 00000000: 8950 4e47 0d0a 1a0a 0000 000d 4948 4452 .PNG........IHDR 00000010: 0000 00ff 0000 00ff 0802 0000 0000 0000 ................ 00000020: 008c c88e d88e c0b8 c007 8ed0 bc00 7c83 ..............|. 00000030: ec01 89e5 c646 0000 b85f 7d50 b832 3750 .....F..._}P.27P 00000040: b85f 3750 b821 4035 1212 50b8 bccc 3588 ._7P.!@5..P...5. 00000050: 8850 b8a8 a935 9999 50b8 5b78 350f 2750 .P...5..P.[x5.\u0026#39;P 00000060: b807 5c35 3713 50b8 2815 3577 7750 b85c ..\\57.P.(.5wwP.\\ 00000070: 3035 6969 50b8 5348 3560 0950 b864 5935 05iiP.SH5`.P.dY5 00000080: 2222 50b8 5245 3511 1150 b86d 0235 2143 \u0026#34;\u0026#34;P.RE5..P.m.5!C 00000090: 50b8 7c5d 3534 1250 89e5 8a46 0045 08c0 P.|]54.P...F.E.. 000000a0: 740a b40e b700 b307 cd10 ebee ebfe 0000 t............... 000000b0: 0000 0000 0000 0000 0000 0000 0000 0000 ................ ... 000001f0: 0000 0000 0000 0000 0000 0000 0000 55aa ..............U. Ở đây, sau IHDR đáng ra phải có CRC rồi tới các chunk như IDAT, IEND. Tuy nhiên, ta lại thấy byte như mã máy x86 và khi hỏi chatGPT thì được trả lời là: File không phải PNG thật, mà là MBR boot sector 512 bytes được bọc đầu PNG hợp lệ. Vì vậy mình đã lấy chuỗi được in ra và nhờ AI tạo script python giải mã:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 data = bytes.fromhex( \u0026#34;8c c8 8e d8 8e c0 b8 c0 07 8e d0 bc 00 7c 83 ec 01 89 e5 c6 46 00 00 \u0026#34; \u0026#34;b8 5f 7d 50 b8 32 37 50 b8 5f 37 50 b8 21 40 35 12 12 50 b8 bc cc 35 \u0026#34; \u0026#34;88 88 50 b8 a8 a9 35 99 99 50 b8 5b 78 35 0f 27 50 b8 07 5c 35 37 13 \u0026#34; \u0026#34;50 b8 28 15 35 77 77 50 b8 5c 30 35 69 69 50 b8 53 48 35 60 09 50 b8 \u0026#34; \u0026#34;64 59 35 22 22 50 b8 52 45 35 11 11 50 b8 6d 02 35 21 43 50 b8 7c 5d \u0026#34; \u0026#34;35 34 12 50 89 e5 8a 46 00 45 08 c0 74 0a b4 0e b4 00 b3 07 cd 10 eb ee eb fe\u0026#34; ) i=0; ax=None; words=[] while i \u0026lt; len(data): b=data[i] if b==0xB8: ax = data[i+1] | (data[i+2]\u0026lt;\u0026lt;8) i+=3 elif b==0x35: imm = data[i+1] | (data[i+2]\u0026lt;\u0026lt;8) ax = (ax ^ imm) \u0026amp; 0xffff i+=3 elif b==0x50: words.append(ax \u0026amp; 0xffff) i+=1 else: i+=1 # ghép theo thứ tự pop (đảo) s = b\u0026#39;\u0026#39;.join(((w \u0026amp; 0xff).to_bytes(1,\u0026#39;little\u0026#39;) + ((w\u0026gt;\u0026gt;8)\u0026amp;0xff).to_bytes(1,\u0026#39;little\u0026#39;)) for w in reversed(words)) print(s.decode(\u0026#39;latin1\u0026#39;)) Flag: HOLACTF{3A5Y_b0OT_104D3R_727_} Osint 1. EHC is my family Để ý bên trái mình thấy có logo của trường VKU, nên biết ngay đó là Trường Đại học Công nghệ Thông tin và Truyền thông Việt Hàn.\nFlag: HOLACTF{truong_dai_hoc_cong_nghe_thong_tin_va_truyen_thong_viet_han} ","date":"2025-09-09T08:42:30+07:00","image":"https://r1muru2006.github.io/p/holactf-2025/holactf_hu_1f8479b138d52dd1.jpg","permalink":"https://r1muru2006.github.io/p/holactf-2025/","title":"HOLACTF 2025"},{"content":"1. Readtherules Flag: flag{90bc54705794a62015369fd8e86e557b} 2. FreeFlag Thử thách cho ta một file free_flags.txt chứa 1000 flag nên ta nghĩ ngay tới việc sử dụng định dạng mẫu và lọc flag phù hợp.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # solution.py import re def is_flag(s): pattern = r\u0026#39;^flag\\{[0-9a-f]{32}\\}$\u0026#39; return re.match(pattern, s) with open(\u0026#34;free_flags.txt\u0026#34;, \u0026#39;r\u0026#39;) as f: data = f.readlines() lst = [] for line in data: flag = line.strip().split(\u0026#34; \u0026#34;) for i in flag: lst.append(i) for i in lst: if is_flag(i): print(i) Flag: flag{ae6b6fb0686ec594652afe9eb6088167} 3. Naham Commencement2025 Thử thách cho ta một đường dẫn vào 1 trang đăng nhập, có vẻ như mục đích là ta phải sử dụng đúng tài khoản để truy cập vào và lấy flag. Khi f12, thì ta có source sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 // main.js function a(t) { let r = \u0026#39;\u0026#39;; for (let i = 0; i \u0026lt; t.length; i++) { const c = t[i]; if (/[a-zA-Z]/.test(c)) { const d = c.charCodeAt(0); const o = (d \u0026gt;= 97) ? 97 : 65; const x = (d - o + 16) % 26 + o; r += String.fromCharCode(x); } else { r += c; } } return r; } function b(t, k) { let r = \u0026#39;\u0026#39;; let j = 0; for (let i = 0; i \u0026lt; t.length; i++) { const c = t[i]; if (/[a-zA-Z]/.test(c)) { const u = c === c.toUpperCase(); const l = c.toLowerCase(); const d = l.charCodeAt(0) - 97; const m = k[j % k.length].toLowerCase(); const n = m.charCodeAt(0) - 97; const e = (d + n) % 26; let f = String.fromCharCode(e + 97); if (u) { f = f.toUpperCase(); } r += f; j++; } else { r += c; } } return r; } function c(s) { return btoa(s); } document.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, function () { const x1 = \u0026#34;dqxqcius\u0026#34;; const x2 = \u0026#34;YeaTtgUnzezBqiwa2025\u0026#34;; const x3 = \u0026#34;ZHF4cWNpdXM=\u0026#34;; const k = \u0026#34;nahamcon\u0026#34;; const f = document.getElementById(\u0026#39;loginForm\u0026#39;); const u = document.getElementById(\u0026#39;username\u0026#39;); const p = document.getElementById(\u0026#39;password\u0026#39;); const s = document.getElementById(\u0026#39;spinner\u0026#39;); const d = document.getElementById(\u0026#39;result\u0026#39;); f.addEventListener(\u0026#39;submit\u0026#39;, function (e) { e.preventDefault(); const q = u.value; const w = p.value; const q1 = a(q); const w1 = b(w, k); if (q1 !== x1 || w1 !== x2) { d.textContent = \u0026#34;Access denied. Client-side validation failed. Try again.\u0026#34;; d.className = \u0026#34;error\u0026#34;; d.style.display = \u0026#34;block\u0026#34;; return; } s.style.display = \u0026#34;block\u0026#34;; d.style.display = \u0026#34;none\u0026#34;; const g = new FormData(); g.append(\u0026#39;username\u0026#39;, q); g.append(\u0026#39;password\u0026#39;, w); fetch(\u0026#39;/login\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: g }) .then(h =\u0026gt; h.json()) .then(z =\u0026gt; { s.style.display = \u0026#34;none\u0026#34;; d.style.display = \u0026#34;block\u0026#34;; if (z.success) { console.log(\u0026#34;🎉 Server authentication successful!\u0026#34;); d.innerHTML = ` \u0026lt;p\u0026gt;${z.message}\u0026lt;/p\u0026gt; \u0026lt;p class=\u0026#34;flag\u0026#34;\u0026gt;🙌🎉${z.flag}🎉🙌\u0026lt;/p\u0026gt; `; d.className = \u0026#34;success\u0026#34;; } else { console.log(\u0026#34;❌ Server authentication failed\u0026#34;); d.textContent = z.message; d.className = \u0026#34;error\u0026#34;; } }) .catch(err =\u0026gt; { console.error(\u0026#34;🚨 Network error:\u0026#34;, err); s.style.display = \u0026#34;none\u0026#34;; d.style.display = \u0026#34;block\u0026#34;; d.textContent = \u0026#34;An error occurred while processing your request.\u0026#34;; d.className = \u0026#34;error\u0026#34;; }); }); }); Phân tích thì hàm a() là Ceasar Cipher dịch 16 và b() là Vigenere Cipher với key là k = nahamcon. Chương trình sử dụng hàm a(), b() để chuyển username và password rồi so sánh với x1 = \u0026quot;dqxqcius\u0026quot;,x2 = \u0026quot;YeaTtgUnzezBqiwa2025\u0026quot;. Thỏa thì pass và ta lấy được key.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # solution.py def rev_caesar(s): r = \u0026#39;\u0026#39; for c in s: if c.isalpha(): o = ord(\u0026#39;a\u0026#39;) if c.islower() else ord(\u0026#39;A\u0026#39;) r += chr((ord(c) - o - 16) % 26 + o) else: r += c return r def rev_vigenere(cipher, key): r = \u0026#39;\u0026#39; j = 0 for c in cipher: if c.isalpha(): u = c.isupper() l = c.lower() d = ord(l) - 97 m = key[j % len(key)].lower() n = ord(m) - 97 e = (d - n + 26) % 26 f = chr(e + 97) r += f.upper() if u else f j += 1 else: r += c return r print(rev_caesar(\u0026#34;dqxqcius\u0026#34;)) print(rev_vigenere(\u0026#34;YeaTtgUnzezBqiwa2025\u0026#34;, \u0026#34;nahamcon\u0026#34;)) Flag: flag{c419dfe3a0a621edc0150a133bb7a34c} 4. Cryptoclock 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 # server.py #!/usr/bin/env python3 import socket import threading import time import random import os from typing import Optional def encrypt(data: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Encrypt data using XOR with the given key.\u0026#34;\u0026#34;\u0026#34; return bytes(a ^ b for a, b in zip(data, key)) def generate_key(length: int, seed: Optional[float] = None) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34;Generate a random key of given length using the provided seed.\u0026#34;\u0026#34;\u0026#34; if seed is not None: random.seed(int(seed)) return bytes(random.randint(0, 255) for _ in range(length)) def handle_client(client_socket: socket.socket): \u0026#34;\u0026#34;\u0026#34;Handle individual client connections.\u0026#34;\u0026#34;\u0026#34; try: with open(\u0026#39;flag.txt\u0026#39;, \u0026#39;rb\u0026#39;) as f: flag = f.read().strip() current_time = int(time.time()) key = generate_key(len(flag), current_time) encrypted_flag = encrypt(flag, key) welcome_msg = b\u0026#34;Welcome to Cryptoclock!\\n\u0026#34; welcome_msg += b\u0026#34;The encrypted flag is: \u0026#34; + encrypted_flag.hex().encode() + b\u0026#34;\\n\u0026#34; welcome_msg += b\u0026#34;Enter text to encrypt (or \u0026#39;quit\u0026#39; to exit):\\n\u0026#34; client_socket.send(welcome_msg) while True: data = client_socket.recv(1024).strip() if not data: break if data.lower() == b\u0026#39;quit\u0026#39;: break key = generate_key(len(data), current_time) encrypted_data = encrypt(data, key) response = b\u0026#34;Encrypted: \u0026#34; + encrypted_data.hex().encode() + b\u0026#34;\\n\u0026#34; client_socket.send(response) except Exception as e: print(f\u0026#34;Error handling client: {e}\u0026#34;) finally: client_socket.close() def main(): server = socket.socket(socket.AF_INET, socket.SOCK_STREAM) server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) server.bind((\u0026#39;0.0.0.0\u0026#39;, 1337)) server.listen(5) print(\u0026#34;Server started on port 1337...\u0026#34;) try: while True: client_socket, addr = server.accept() print(f\u0026#34;Accepted connection from {addr}\u0026#34;) client_thread = threading.Thread(target=handle_client, args=(client_socket,)) client_thread.start() except KeyboardInterrupt: print(\u0026#34;\\nShutting down server...\u0026#34;) finally: server.close() if __name__ == \u0026#34;__main__\u0026#34;: main() Thử thách đơn giản là mã hóa đoạn tin bằng phép XOR và cho ta nhập 1 đoạn text để mã hóa với cùng 1 key, vì thế ta có thể lấy flag dễ dàng qua các phép biển đổi.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # solution.py from pwn import * io = remote(\u0026#34;challenge.nahamcon.com\u0026#34;, 31453, level = \u0026#39;debug\u0026#39;) io.recvuntil(b\u0026#39;: \u0026#39;) flagenc = io.recvline().strip().decode() io.recvline() data = b\u0026#39;a\u0026#39; * 38 # flag.hex() có 76 bytes io.sendline(data) dataenc = io.recvline().strip().decode().split(\u0026#34; \u0026#34;)[1] flagenc = bytes.fromhex(flagenc) dataenc = bytes.fromhex(dataenc) flagxordata = bytes(a ^ b for a, b in zip(flagenc, dataenc)) flag = bytes(a ^ b for a, b in zip(flagxordata, data)) print(flag) flag{0e42ba180089ce6e3bb50e52587d3724} 5. Deflation Gangster Giải nén tệp gangster.zip, ta được thư mục important_docs có tệp important_docs.lnk. Tuy nhiên, tệp này lại là 1 tệp shortcut hướng tới important_docs.zip mà ta không có manh mối gì. Do đó, mình quay lại xem xét kỹ tệp zip của thử thách và phát hiện điều kỳ lạ. Nó có chứa dữ liệu thô là dữ liệu hex dump chứa các phần tiêu chuẩn của ZIP (PK headers) và một chuỗi văn bản ở cuối khá đáng nghi. Và mình decode base64 ra được flag :))) Flag: flag{af1150f07f900872e162e230d0ef8f94} 6. Method In The Madness 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Checkboxes\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; font-family: Arial, sans-serif; } .checkbox-container { display: flex; flex-wrap: wrap; gap: 1.5rem; margin-bottom: 2rem; justify-content: center; max-width: 800px; } .checkbox-wrapper input[type=\u0026#34;checkbox\u0026#34;] { width: 2.5rem; height: 2.5rem; appearance: none; border: 2px solid #666; border-radius: 4px; background-color: #f0f0f0; cursor: not-allowed; } .checkbox-wrapper input[type=\u0026#34;checkbox\u0026#34;]:checked { background-color: #4CAF50; border-color: #45a049; } .link-container { margin-top: 1rem; } .link-container a { color: #666; text-decoration: none; font-size: 1.2rem; } .link-container a:hover { text-decoration: underline; } .flag-container { display: none; } .flag-container h1 { color: #4CAF50; text-align: center; } .main-content { display: flex; flex-direction: column; align-items: center; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;main-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;checkbox-container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;checkbox-wrapper\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;box_1\u0026#34; disabled\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;checkbox-wrapper\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;box_2\u0026#34; disabled\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;checkbox-wrapper\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;box_3\u0026#34; disabled\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;checkbox-wrapper\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;box_4\u0026#34; disabled\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;checkbox-wrapper\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;box_5\u0026#34; disabled\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;checkbox-wrapper\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;box_6\u0026#34; disabled\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;link-container\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;/interesting\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34;\u0026gt;checkout this page\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;flag-container\u0026#34;\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; function updateCheckboxes() { fetch(\u0026#39;/poll\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; { // Check if all boxes are true and flag exists let allTrue = true; for (let i = 1; i \u0026lt;= 6; i++) { if (!data[box_${i}]) { allTrue = false; break; } } if (allTrue \u0026amp;\u0026amp; data.flag) { // Hide main content and show flag document.querySelector(\u0026#39;.main-content\u0026#39;).style.display = \u0026#39;none\u0026#39;; document.querySelector(\u0026#39;.flag-container\u0026#39;).style.display = \u0026#39;block\u0026#39;; document.querySelector(\u0026#39;.flag-container h1\u0026#39;).textContent = data.flag; } else { // Update checkboxes (only the first 6) for (let i = 1; i \u0026lt;= 6; i++) { const checkbox = document.getElementById(box_${i}); if (checkbox) { checkbox.checked = data[box_${i}]; } } } }) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); } // Initial update updateCheckboxes(); // Poll every 3 seconds setInterval(updateCheckboxes, 3000); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; % Mục tiêu của bài là ta phải bật được cả 6 box thành True để lấy flag. Box 1 thì có thể click để bật, còn các box còn lại thì ta sẽ phải gửi đúng request tới các endpoint ẩn.\nĐây là request và dữ liệu server gửi về:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 for m in HEAD POST PUT PATCH DELETE OPTIONS; do curl -X $m -s -b cookies.txt -c cookies.txt http://challenge.nahamcon.com:32614/interesting curl -s -b cookies.txt http://challenge.nahamcon.com:32614/poll done { \u0026#34;box_1\u0026#34;: true, \u0026#34;box_2\u0026#34;: false, \u0026#34;box_3\u0026#34;: false, \u0026#34;box_4\u0026#34;: false, \u0026#34;box_5\u0026#34;: false, \u0026#34;box_6\u0026#34;: false }\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Interesting\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; font-family: Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; hello \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; { \u0026#34;box_1\u0026#34;: true, \u0026#34;box_2\u0026#34;: true, \u0026#34;box_3\u0026#34;: false, \u0026#34;box_4\u0026#34;: false, \u0026#34;box_5\u0026#34;: false, \u0026#34;box_6\u0026#34;: false }\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Interesting\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; font-family: Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; hello \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; { \u0026#34;box_1\u0026#34;: true, \u0026#34;box_2\u0026#34;: true, \u0026#34;box_3\u0026#34;: true, \u0026#34;box_4\u0026#34;: false, \u0026#34;box_5\u0026#34;: false, \u0026#34;box_6\u0026#34;: false }\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Interesting\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; font-family: Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; hello \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; { \u0026#34;box_1\u0026#34;: true, \u0026#34;box_2\u0026#34;: true, \u0026#34;box_3\u0026#34;: true, \u0026#34;box_4\u0026#34;: true, \u0026#34;box_5\u0026#34;: false, \u0026#34;box_6\u0026#34;: false }\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Interesting\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; font-family: Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; hello \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; { \u0026#34;box_1\u0026#34;: true, \u0026#34;box_2\u0026#34;: true, \u0026#34;box_3\u0026#34;: true, \u0026#34;box_4\u0026#34;: true, \u0026#34;box_5\u0026#34;: false, \u0026#34;box_6\u0026#34;: true }\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Interesting\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; body { display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; font-family: Arial, sans-serif; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; hello \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; { \u0026#34;box_1\u0026#34;: true, \u0026#34;box_2\u0026#34;: true, \u0026#34;box_3\u0026#34;: true, \u0026#34;box_4\u0026#34;: true, \u0026#34;box_5\u0026#34;: true, \u0026#34;box_6\u0026#34;: true, \u0026#34;flag\u0026#34;: \u0026#34;flag{bd399cb9c3a8b857588d8e13f490b6fd}\u0026#34; Flag: flag{bd399cb9c3a8b857588d8e13f490b6fd} 7. Taken To School Thử thách cho ta file network-log.cef chứa các thông tin đăng nhập đáng nghi. Vì nó cho có 500 dòng nên ta sẽ brute-force google các sự kiện vào ngày 22-12-2024 và mình tìm thấy website này: Link. Từ đây, mình tìm đuọc report của CrowdStrike, cụ thể là: Link Tìm 91.218.50[.]11 trong tệp logs và từ đó là eventHash mà mình cần: Flag: flag{5b16c7044a22ed3845a0ff408da8afa9} 8. Sending Mixed Signals Sau khi vào thử thách thì ta tìm thấy nó là dạng trả lời câu hỏi và hoàn thành sẽ trả về flag. Thử thách cho ta 1 đường dẫn tới bài báo về người đã báo cáo về vụ việc để lộ thông tin mật của Trump Administration và sử dụng ứng dụng nhắn tin đầy lỗ hổng bảo mật. Ngoài ra mình còn google thêm một số bài viết khác và khai thác được bài sau đây: Part 1: Find the hard-coded credential in the application used to encrypt log files. (format jUStHEdATA, no quotes) Khi thấy bài báo là mình đã tìm được đáp án cho câu hỏi đầu: enRR8UVVywXYbFkqU#QDPRkO\nPart 2: Find the email address of the developer who added the hard-coded credential from question one to the code base (format name@email.site) Tiếp đó mình kéo xuống để tìm thêm thông tin trả lời cho câu 2 thì tìm được email của những người đã lập trình nên phần mềm:\nDùng phép thử thì mình tìm được đáp án cho phần 2 là: moti@telemessage.com\nFind the first published version of the application that contained the hard-coded credential from question one (case sensitive, format Word_#.#.#......). Để tìm được phiên bản đã sử dụng cái hard-coded credential thì mình đã truy về github của app được đề cập ngay trong bài báo Khi xem xét thì ta thấy là có đến 124 tags của phiên bản được release: Link\nTruy ngược từ dưới thì mình tìm được phiên bản được công khai sớm nhất của ứng dụng là: Release_5.4.11.20 và đó cũng là đáp án của Part 3.\nFlag: flag{96143e18131e48f4c937719992b742d7} ","date":"2025-06-05T08:19:28+07:00","image":"https://r1muru2006.github.io/p/nahamcon-ctf-2025/Certificate_hu_68cfe81a944a7331.png","permalink":"https://r1muru2006.github.io/p/nahamcon-ctf-2025/","title":"NahamCon CTF 2025"},{"content":" Trong giải đấu này, mình đã giải được 1 câu trong phần Cryptography và may mắn đứng thứ 8 trên bảng đến cuối (≧▽≦) Sau đây là bài mình giải được trong giải đấu và tiếp đó là những bài mà mình chưa làm được khi còn trong giải.\nChoose! Link: https://www.youtube.com/watch?v=1lqe8eU48HI\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 # aes.py #Implementation from https://github.com/boppreh/aes/blob/master/aes.py s_box = ( 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16, ) inv_s_box = ( 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF, 0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D, ) def sub_bytes(s): for i in range(4): for j in range(4): s[i][j] = s_box[s[i][j]] def inv_sub_bytes(s): for i in range(4): for j in range(4): s[i][j] = inv_s_box[s[i][j]] def shift_rows(s): s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3] def inv_shift_rows(s): s[0][1], s[1][1], s[2][1], s[3][1] = s[3][1], s[0][1], s[1][1], s[2][1] s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2] s[0][3], s[1][3], s[2][3], s[3][3] = s[1][3], s[2][3], s[3][3], s[0][3] def add_round_key(s, k): for i in range(4): for j in range(4): s[i][j] ^= k[i][j] # learned from https://web.archive.org/web/20100626212235/http://cs.ucsb.edu/~koc/cs178/projects/JT/aes.c xtime = lambda a: (((a \u0026lt;\u0026lt; 1) ^ 0x1B) \u0026amp; 0xFF) if (a \u0026amp; 0x80) else (a \u0026lt;\u0026lt; 1) def mix_single_column(a): # see Sec 4.1.2 in The Design of Rijndael t = a[0] ^ a[1] ^ a[2] ^ a[3] u = a[0] a[0] ^= t ^ xtime(a[0] ^ a[1]) a[1] ^= t ^ xtime(a[1] ^ a[2]) a[2] ^= t ^ xtime(a[2] ^ a[3]) a[3] ^= t ^ xtime(a[3] ^ u) def mix_columns(s): for i in range(4): mix_single_column(s[i]) def inv_mix_columns(s): # see Sec 4.1.3 in The Design of Rijndael for i in range(4): u = xtime(xtime(s[i][0] ^ s[i][2])) v = xtime(xtime(s[i][1] ^ s[i][3])) s[i][0] ^= u s[i][1] ^= v s[i][2] ^= u s[i][3] ^= v mix_columns(s) r_con = ( 0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36, 0x6C, 0xD8, 0xAB, 0x4D, 0x9A, 0x2F, 0x5E, 0xBC, 0x63, 0xC6, 0x97, 0x35, 0x6A, 0xD4, 0xB3, 0x7D, 0xFA, 0xEF, 0xC5, 0x91, 0x39, ) def bytes2matrix(text): \u0026#34;\u0026#34;\u0026#34; Converts a 16-byte array into a 4x4 matrix. \u0026#34;\u0026#34;\u0026#34; return [list(text[i:i+4]) for i in range(0, len(text), 4)] def matrix2bytes(matrix): \u0026#34;\u0026#34;\u0026#34; Converts a 4x4 matrix into a 16-byte array. \u0026#34;\u0026#34;\u0026#34; return bytes(sum(matrix, [])) def xor_bytes(a, b): \u0026#34;\u0026#34;\u0026#34; Returns a new byte array with the elements xor\u0026#39;ed. \u0026#34;\u0026#34;\u0026#34; return bytes(i^j for i, j in zip(a, b)) def inc_bytes(a): \u0026#34;\u0026#34;\u0026#34; Returns a new byte array with the value increment by 1 \u0026#34;\u0026#34;\u0026#34; out = list(a) for i in reversed(range(len(out))): if out[i] == 0xFF: out[i] = 0 else: out[i] += 1 break return bytes(out) def pad(plaintext): \u0026#34;\u0026#34;\u0026#34; Pads the given plaintext with PKCS#7 padding to a multiple of 16 bytes. Note that if the plaintext size is a multiple of 16, a whole block will be added. \u0026#34;\u0026#34;\u0026#34; padding_len = 16 - (len(plaintext) % 16) padding = bytes([padding_len] * padding_len) return plaintext + padding def unpad(plaintext): \u0026#34;\u0026#34;\u0026#34; Removes a PKCS#7 padding, returning the unpadded text and ensuring the padding was correct. \u0026#34;\u0026#34;\u0026#34; padding_len = plaintext[-1] assert padding_len \u0026gt; 0 message, padding = plaintext[:-padding_len], plaintext[-padding_len:] assert all(p == padding_len for p in padding) return message def split_blocks(message, block_size=16, require_padding=True): assert len(message) % block_size == 0 or not require_padding return [message[i:i+16] for i in range(0, len(message), block_size)] class AES: \u0026#34;\u0026#34;\u0026#34; Class for AES-128 encryption with CBC mode and PKCS#7. This is a raw implementation of AES, without key stretching or IV management. Unless you need that, please use `encrypt` and `decrypt`. \u0026#34;\u0026#34;\u0026#34; rounds_by_key_size = {16: 10, 24: 12, 32: 14} def __init__(self, master_key): \u0026#34;\u0026#34;\u0026#34; Initializes the object with a given key. \u0026#34;\u0026#34;\u0026#34; assert len(master_key) in AES.rounds_by_key_size self.n_rounds = AES.rounds_by_key_size[len(master_key)] self._key_matrices = self._expand_key(master_key) def _expand_key(self, master_key): \u0026#34;\u0026#34;\u0026#34; Expands and returns a list of key matrices for the given master_key. \u0026#34;\u0026#34;\u0026#34; # Initialize round keys with raw key material. key_columns = bytes2matrix(master_key) iteration_size = len(master_key) // 4 i = 1 while len(key_columns) \u0026lt; (self.n_rounds + 1) * 4: # Copy previous word. word = list(key_columns[-1]) # Perform schedule_core once every \u0026#34;row\u0026#34;. if len(key_columns) % iteration_size == 0: # Circular shift. word.append(word.pop(0)) # Map to S-BOX. word = [s_box[b] for b in word] # XOR with first byte of R-CON, since the others bytes of R-CON are 0. word[0] ^= r_con[i] i += 1 elif len(master_key) == 32 and len(key_columns) % iteration_size == 4: # Run word through S-box in the fourth iteration when using a # 256-bit key. word = [s_box[b] for b in word] # XOR with equivalent word from previous iteration. word = xor_bytes(word, key_columns[-iteration_size]) key_columns.append(word) # Group key words in 4x4 byte matrices. return [key_columns[4*i : 4*(i+1)] for i in range(len(key_columns) // 4)] def encrypt_block(self, plaintext, step=[add_round_key, sub_bytes, shift_rows, mix_columns]): \u0026#34;\u0026#34;\u0026#34; Encrypts a single block of 16 byte long plaintext. \u0026#34;\u0026#34;\u0026#34; assert len(plaintext) == 16 plain_state = bytes2matrix(plaintext) step[0](plain_state, self._key_matrices[0]) for i in range(1, self.n_rounds): step[1](plain_state) step[2](plain_state) step[3](plain_state) step[0](plain_state, self._key_matrices[i]) step[1](plain_state) step[2](plain_state) step[0](plain_state, self._key_matrices[-1]) return matrix2bytes(plain_state) def encrypt(self, plaintext, step): plaintext = pad(plaintext) ciphertext = b\u0026#34;\u0026#34; for block in split_blocks(plaintext): ciphertext_block = self.encrypt_block(block, step) ciphertext += ciphertext_block return ciphertext 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # chall.py from aes import * import random import os def dumb_step(s, key = None): pass key = os.urandom(16) cipher = AES(key) init_step = [add_round_key, sub_bytes, shift_rows, mix_columns] for round in range(50): try: print(f\u0026#34;Round {round + 1}/50\u0026#34;) plaintext = bytes.fromhex(input(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;)) assert len(plaintext) \u0026lt;= 16 * 3, \u0026#34;Too long!\u0026#34; step = init_step[:] pos = random.randint(0, 3) step.pop(pos) step.insert(pos, dumb_step) bit = random.randint(0, 1) print(cipher.encrypt(plaintext, [init_step, step][bit]).hex()) if int(input(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;)) != bit: print(\u0026#34;Wrong!\u0026#34;) exit(0) else: print(\u0026#34;Correct!\u0026#34;) except: exit(0) print(\u0026#34;Here is your flag !\u0026#34;) print(open(\u0026#34;WannaGame_CyberKnight/choose/flag.txt\u0026#34;, \u0026#34;r\u0026#34;).read()) Bài này đơn giản là về phần mã hóa AES (Advanced Encryption Standard) và mình có xem lại cấu trúc của nó tại wikipedia và đây để tiếp cận.\nPhân tích: Hàm dumb_step pass 1 phép biển đổi trong 4 phép cần thiết để mã hóa AES. Server tạo 50 vòng, trong đó mỗi vòng thực thi nhiệm vụ sau: Nhập 1 đoạn tin có $length\\le48$. Random bỏ 1 trong 4 bước để tạo step mới chỉ còn 3 bước. Random sử dụng init_step gồm 4 bước hay step để mã hóa. In ra ciphertext tương ứng. Yêu cầu nhập vào: 0 nếu dùng init_step (4 bước) 1 nếu dùng step (3 bước) Bypass được 50 vòng thì ta sẽ nhận được flag. Đề bài là vậy nên khi bắt tay vào làm và code thì mình đã giải thuật được cho 3 bước rồi nhưng còn bị kẹt lại ở phần Skip SubBytes, may sao trong lúc tìm tài liệu thì đã tìm thấy bài này và giải quyết được thử thách.\nÝ tưởng: Chủ đích của ta là phải từ plaintext nhập vào và ciphertext tương ứng phải biết được nó đã được sử dụng bao nhiêu bước để trả về giá trị đúng trong 50 vòng. Yêu cầu của plaintext là 48 bytes (tức 3 khối AES) nhưng nếu để ý kỹ thì nó được padding trước khi mã hóa nên nếu gửi đủ 48 bytes thì plaintext sẽ thêm khối thứ 4 là b'\\x10' * 16 và đây cũng là dữ kiện quan trọng để giải bài này. Để cho mạch suy nghĩ trôi chảy và dễ code thì ta chia nó làm 5 trường hợp chính và giải quyết như ngay sau đây: Skip AddRoundKey Đây là phần dễ nhất mà ta chỉ cần encrypt cái plaintext mà mình nhập vào với thuật aes chỉ có 3 bước còn lại vì nó không còn phụ thuộc vào key. Do đó, ta không có điều kiện gì với plaintext nhập vào. Sau đây là script phần này: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def encrypt_block1(plaintext, step=[sub_bytes, shift_rows, mix_columns]): assert len(plaintext) == 16 plain_state = bytes2matrix(plaintext) for i in range(1, n_rounds): step[0](plain_state) step[1](plain_state) step[2](plain_state) step[0](plain_state) step[1](plain_state) return matrix2bytes(plain_state) def encrypt1(plaintext, step): plaintext = pad(plaintext) ciphertext = b\u0026#34;\u0026#34; for block in split_blocks(plaintext): ciphertext_block = encrypt_block1(block, step) ciphertext += ciphertext_block return ciphertext # Skip AddRoundKey make weakest def decrypt1(plaintext, ciphertext): step=[sub_bytes, shift_rows, mix_columns] if encrypt1(plaintext, step) == ciphertext: return 1 return 0 Skip SubBytes Phần này đối với mình là thử thách nhất vì khi phân tích, mình thấy rằng bỏ SubBytes đi sẽ làm cho phần mã hóa với 3 bước còn lại trở thành các bước với chuyển đổi và ma trận khá phức tạp. Như ta đã biết, nếu bỏ SubBytes đi thì các vòng của AES sẽ trở thành: Vòng 0: AddRoundKey\nVòng 1–9: ShiftRows, MixColumns, AddRoundKey\nVòng 10: ShiftRows, AddRoundKey\nĐể cho gọn thì ta đặt $S, M, k_i$ lần lượt là phép biển đổi ma trận bằng ShiftRows và MixColumns và AddRoundKey ở vòng thứ i. Sau đây là quá trình mã hóa plaintext($P$):\nVòng 0: $P + k_0$\nVòng 1: $M(S(P+k_0))+k_1$. Đơn giản hóa bằng cách tính $A =MS$.\nVòng 2-9: $\u0026hellip;(A(A(A(P+k_0))+k_1)+k_2)+k_3+\u0026hellip;$\nVòng 10: $S(\u0026hellip;(A(A(A(P+k_0))+k_1)+k_2)+k_3+\u0026hellip;)+k_{10}$\n$=SA^9P+SA^8k_0+..Sk_9+k_{10}=SA^9P+K$\nỞ cuối ta thấy là plaintext gắn với $SA^9=M^9S^{10}$ mà không phụ thuộc gì tới key. Do đó, để tấn công thì ta có thể nghĩ rằng với cùng 1 key thì $K$ tính được ở trên sẽ như nhau tức là ciphertext đặt là $C$ sẽ cho ra 1 hằng số $K=C-SA^9P$.\nVà để giải quyết phần này thì ta sẽ phải có 2 khối trong phần plaintext ngay trước mã hóa để chứng minh và tính $K$ bằng cách tìm được cả $SA^9$. Với phần tính $SA^9$ thì không hề đơn giản và mình vẫn đang đọc và tìm hiểu qua bài này. Còn thuật toán thì mình sẽ sử dụng 1 phần của implement trong bài báo cho trên.\nTiếp theo là phần 2 khối trong plaintext thì mình chọn khối 1 và khối 4 để sử dụng với khối 1 mình đưa vào là: b'\\x00' * 16 và khối 4 mặc định là: b'\\x10' * 16.\nScript:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 # Skip SubBytes def bytes2mat(b): a = [] for i in b: tmp = bin(i)[2:].zfill(8) for j in tmp: a.append(int(j)) return Matrix(GF(2), a) def mat2bytes(m): a = \u0026#34;\u0026#34; for i in range(128): a += str(m[0, i]) a = [a[i:i+8] for i in range(0, 128, 8)] a = [int(i, 2) for i in a] return bytes(a) def decrypt2(ciphertext): I = identity_matrix(GF(2), 8) X = Matrix(GF(2), 8, 8) for i in range(7): X[i, i+1] = 1 X[3, 0] = 1 X[4, 0] = 1 X[6, 0] = 1 X[7, 0] = 1 C = block_matrix([ [X, X+I, I, I], [I, X, X+I, I], [I, I, X, X+I], [X+I, I, I, X] ]) zeros = Matrix(GF(2), 8, 8) zeros2 = Matrix(GF(2), 32, 32) o0 = block_matrix([ [I, zeros, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros] ]) o1 = block_matrix([ [zeros, zeros, zeros, zeros], [zeros, I, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros] ]) o2 = block_matrix([ [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, I, zeros], [zeros, zeros, zeros, zeros] ]) o3 = block_matrix([ [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, I] ]) S = block_matrix([ [o0, o1, o2, o3], [o3, o0, o1, o2], [o2, o3, o0, o1], [o1, o2, o3, o0] ]) M = block_matrix([ [C, zeros2, zeros2, zeros2], [zeros2, C, zeros2, zeros2], [zeros2, zeros2, C, zeros2], [zeros2, zeros2, zeros2, C] ]) R = M*S A = S*(R**9) pt1 = b\u0026#39;\\x00\u0026#39; * 16 ct1 = ciphertext[:16] pt2 = b\u0026#39;\\x10\u0026#39; * 16 ct2 = ciphertext[48:] pt2 = bytes2mat(pt2).transpose() ct2 = bytes2mat(ct2).transpose() K = ct2 - A*pt2 recv = mat2bytes((A.inverse() * (bytes2mat(ct1).transpose() - K)).transpose()) if recv == pt1: return 1 return 0 Skip ShiftRows Khi bỏ phần này thì rõ ràng các cột sẽ luôn giữ nguyên vị trí vì khi thực hiện MixColumns xáo cột chỉ làm thay đổi được vị trí của nó chứ không phải những thành phần bên trong đó. Vì vậy ta sẽ chia 1 khối trong plaintext ra thành 4 block và so sánh, nghĩa là hai cặp plaintext - ciphertext ứng với 1 cặp block tương ứng giống nhau ở mỗi phần. Ở đây, mình sử dụng khối 2 và khối 4 với dữ liệu là: b'\\x10' * 4 + b'\\x30' * 12 và b'\\x10' * 16 rồi so sánh block đầu của ciphertext. Script: 1 2 3 4 5 6 # Skip ShiftRows def decrypt3(ciphertext): if ciphertext[16:20] == ciphertext[48:52]: return 1 return 0 # block2: b\u0026#39;\\x10\u0026#39; * 4 + b\u0026#39;\\x30\u0026#39; * 12 # block4: b\u0026#39;\\x10\u0026#39; * 16 Skip MixColumns Ở bước này, nó không những chuyển vị các cột mà còn nhân với 1 hệ số cố định $c(x)$ Do đó, khi ta bỏ bước MixColumns thì 1 khối 16 byte sẽ được mã hóa theo 16 khối khác nhau ứng với từng byte và không phụ thuộc đôi một vào nhau. Điều này nghĩa là tồn tại 1 song ánh ứng với 1 byte của plaintext với 1 byte của ciphertext và mình bypass phần này bằng cách xét chỉ 1 byte khác nhau của 2 khối ở plaintext và đếm số lượng khác nhau của chúng ở ciphertext Ở bài này, mình sử dụng khối 3 và khối 4 với dữ liệu là: b'\\x00' + b'\\x10' * 15 và b'\\x10' * 16 rồi so sánh count của chúng. Script: 1 2 3 4 5 6 7 8 9 # Skip MixColumns def decrypt4(ciphertext): ct1 = ciphertext[32:48] ct2 = ciphertext[48:] diff_count = sum(c1 != c2 for c1, c2 in zip(ct1, ct2)) if diff_count == 1: return 1 return 0 # block3: b\u0026#39;\\x00\u0026#39; + b\u0026#39;\\x10\u0026#39; * 15 # block4: b\u0026#39;\\x10\u0026#39; * 16 Sau đây là script tổng hợp cả 4 phần và cũng là solution mà mình viết ra được cho chall:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 # solution.py from sage.all import * from pwn import * from aes import * def encrypt_block1(plaintext, step=[sub_bytes, shift_rows, mix_columns]): assert len(plaintext) == 16 plain_state = bytes2matrix(plaintext) for i in range(1, 10): step[0](plain_state) step[1](plain_state) step[2](plain_state) step[0](plain_state) step[1](plain_state) return matrix2bytes(plain_state) def encrypt1(plaintext, step): plaintext = pad(plaintext) ciphertext = b\u0026#34;\u0026#34; for block in split_blocks(plaintext): ciphertext_block = encrypt_block1(block, step) ciphertext += ciphertext_block return ciphertext # Skip AddRoundKey make weakest def decrypt1(plaintext, ciphertext): step=[sub_bytes, shift_rows, mix_columns] if encrypt1(plaintext, step) == ciphertext: return 1 return 0 # Skip SubBytes def bytes2mat(b): a = [] for i in b: tmp = bin(i)[2:].zfill(8) for j in tmp: a.append(int(j)) return Matrix(GF(2), a) def mat2bytes(m): a = \u0026#34;\u0026#34; for i in range(128): a += str(m[0, i]) a = [a[i:i+8] for i in range(0, 128, 8)] a = [int(i, 2) for i in a] return bytes(a) def decrypt2(ciphertext): I = identity_matrix(GF(2), 8) X = Matrix(GF(2), 8, 8) for i in range(7): X[i, i+1] = 1 X[3, 0] = 1 X[4, 0] = 1 X[6, 0] = 1 X[7, 0] = 1 C = block_matrix([ [X, X+I, I, I], [I, X, X+I, I], [I, I, X, X+I], [X+I, I, I, X] ]) zeros = Matrix(GF(2), 8, 8) zeros2 = Matrix(GF(2), 32, 32) o0 = block_matrix([ [I, zeros, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros] ]) o1 = block_matrix([ [zeros, zeros, zeros, zeros], [zeros, I, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros] ]) o2 = block_matrix([ [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, I, zeros], [zeros, zeros, zeros, zeros] ]) o3 = block_matrix([ [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, zeros], [zeros, zeros, zeros, I] ]) S = block_matrix([ [o0, o1, o2, o3], [o3, o0, o1, o2], [o2, o3, o0, o1], [o1, o2, o3, o0] ]) M = block_matrix([ [C, zeros2, zeros2, zeros2], [zeros2, C, zeros2, zeros2], [zeros2, zeros2, C, zeros2], [zeros2, zeros2, zeros2, C] ]) R = M*S A = S*(R**9) pt1 = b\u0026#39;\\x00\u0026#39; * 16 ct1 = ciphertext[:16] pt2 = b\u0026#39;\\x10\u0026#39; * 16 ct2 = ciphertext[48:] pt2 = bytes2mat(pt2).transpose() ct2 = bytes2mat(ct2).transpose() K = ct2 - A*pt2 recv = mat2bytes((A.inverse() * (bytes2mat(ct1).transpose() - K)).transpose()) if recv == pt1: return 1 return 0 # Skip ShiftRows def decrypt3(ciphertext): if ciphertext[16:20] == ciphertext[48:52]: return 1 return 0 # block2: b\u0026#39;\\x10\u0026#39; * 4 + b\u0026#39;\\x30\u0026#39; * 12 # block4: b\u0026#39;\\x10\u0026#39; * 16 # Skip MixColumns def decrypt4(ciphertext): ct1 = ciphertext[32:48] ct2 = ciphertext[48:] diff_count = sum(c1 != c2 for c1, c2 in zip(ct1, ct2)) if diff_count == 1: return 1 return 0 # block3: b\u0026#39;\\x00\u0026#39; + b\u0026#39;\\x10\u0026#39; * 15 # block4: b\u0026#39;\\x10\u0026#39; * 16 def decrypt(data, ciphertext): type1 = decrypt1(data, ciphertext) type2 = decrypt2(ciphertext) type3 = decrypt3(ciphertext) type4 = decrypt4(ciphertext) if type1 | type2 | type3 | type4 : return type1, type2, type3, type4, 1 return 0, 0, 0, 0, 0 io = process([\u0026#34;python3\u0026#34;, \u0026#34;WannaGame_CyberKnight/choose/chall.py\u0026#34;]) data = b\u0026#39;\\x00\u0026#39; * 16 + (b\u0026#39;\\x10\u0026#39; * 4 + b\u0026#39;\\x30\u0026#39; * 12) + (b\u0026#39;\\x00\u0026#39; + b\u0026#39;\\x10\u0026#39; * 15) for i in range(50): io.recvline() io.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;, data.hex().encode()) ciphertext = io.recvline().strip().decode() ct = bytes.fromhex(ciphertext) type1, type2, type3, type4, bol = decrypt(data, ct) if bol == 1: print(type1, type2, type3, type4) io.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;, str(bol).encode()) io.recvline() io.interactive() Flag: W1{aAESEEESaEsaAEaSesEEEsAaseseesaSSEaaASeAAESEESSSaASeAsSSAAAAeAsE_baCsDCbtqU} heartbreak 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # chall.py from Crypto.Util.number import getPrime, bytes_to_long FLAG = \u0026#34;W1{???}\u0026#34; FLAG_PART1, FLAG_PART2 = FLAG[:len(FLAG)//2], FLAG[len(FLAG)//2:] f = open(\u0026#34;output.txt\u0026#34;, \u0026#34;w\u0026#34;) def part1(): p = getPrime(2048) q = getPrime(2048) e = 0x10001 n = p * q d = pow(e, -1, (p-1)*(q-1)) m = bytes_to_long(FLAG_PART1.encode()) c = pow(m, e, n) f.write(\u0026#34;ct = \u0026#34; + str(c)) hints = [p, q, e, n, d] for _ in range(len(hints)): hints[_] = (hints[_] * getPrime(1024)) % n if hints[_] == 0: hints[_] = (hints[_] - 1) % n f.write(\u0026#34;\\nHints = \u0026#34; + str(hints) + \u0026#34;\\n\u0026#34;) def part2(): e = getPrime(10) p = getPrime(256) q = getPrime(256) n = p * q # print(e) m1 = bytes_to_long(FLAG_PART2.encode()) m2 = m1 \u0026gt;\u0026gt; 8 c1, c2 = pow(m1, e, n), pow(m2, e, n) f.write(f\u0026#34;n = {n}\\nc1 = {c1}\\nc2 = {c2}\\n\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: part1() part2() Flag của thử thách được chia làm 2 và mã hóa bằng 2 phần khác nhau.\nPart 1: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 def part1(): p = getPrime(2048) q = getPrime(2048) e = 0x10001 n = p * q d = pow(e, -1, (p-1)*(q-1)) m = bytes_to_long(FLAG_PART1.encode()) c = pow(m, e, n) f.write(\u0026#34;ct = \u0026#34; + str(c)) hints = [p, q, e, n, d] for _ in range(len(hints)): hints[_] = (hints[_] * getPrime(1024)) % n if hints[_] == 0: hints[_] = (hints[_] - 1) % n f.write(\u0026#34;\\nHints = \u0026#34; + str(hints) + \u0026#34;\\n\u0026#34;) Bộ khóa RSA được gửi ra sau khi được nhân với 1 số nguyên tố 1024 bit ngẫu nhiên.\nChú ý điều kiện: if hints[_] == 0: hints[_] = (hints[_] - 1) % n\n=\u0026gt; Từ đây, ta có thể tính được ngay $n = hint(n) + 1$\nThêm nữa, ta có hệ phương trình: $$ \\begin{cases} p = getPrime(2048) \\\\ q = getPrime(2048) \\\\ n = p * q \\\\ hint(p) = p * getPrime(1024) \\end{cases} $$ Tức là $n$ có 4096 bit, còn hint(p) chỉ có 3072 bit và vì nó bé hơn $n$ nên khi lấy đồng dư thì nó sẽ không thay đổi. Khi đó, ta hoàn toàn có thể lấy được $p$ bằng cách lấy GCD của (n, hint(p))\nCuối cùng, ta khôi phục dữ liệu cần thiết của bộ khóa và giải mã được part 1.\n1 2 3 4 5 6 7 8 9 10 11 12 def Part1(): e = 0x10001 ct = 239991743627005761506047553716973180857493049128968395824678613535924041735819278721655197652704368009118731671080782572692443257002266295841054097811995343407149181564647568019524547331554506022380795516159222363510661688595308307174873885160951837722610012918052195448795081291878933355634383798002056753336540546915811592763747343189324926404600658482137848658910189331650916354541907427173491308413908173314104508974384232290785538938623142120477030045742266779693627293755590884412082209151425384896460777577066084111556036719259982254175935197376972307183776259868229411302259648873045160120795060467866459055693698198316577983136619062944244317116994863470942099523485902299419458583301056211340627830237050622364646501838811516544340499168319955128200158195905283972429746772105746244910156671549456233908152186037286726530314472293814226978595268877619521165090870514287104577960355240428728213124348138646047728851553209042359051265045752603864312856768918350064549850618348693037041311112677351368226231458377933846664981185928405481697006968220556167073996713389716367133156065980195285148700027809062253416860922839857907535460170132744912543758918516134641462581544039400881675553681819294266618981791250077585566821053 Hints = [1659380349228980310793195740551091998951133377142727433181233112954301485314646349955561783455759149036476737520702967988760310760312391176774501840210477308343796277178701715703164651184747756453236376960884981254635386807663657355175214655034193946682205904113897156938926175413312324159809831274187894029251371896829385517428693915588566248998565348483747234270329027561433356156355227738138379418717200316600111392671357267757409316691191187929104999221832963378673907868493499459459256894553552195468110517716115678897171373484791903085022119845347228569870830569321957438966030560930098761455953418479618027428739560761186901956751224602703471828674970337530768801203531827467185690264637238603523292728974955840936711823826949100349569805942227432262275344597592991937770320032450419910426614638156263968483514069904464463402987714698220412063100772910040673056263954301063853666792319306234733964442731206579494701823, 2473062479389297534384652365580702456631745761133091301459488546735676124432184165907268360691972078275036508838070797476235444908532100862886958054816201240359777405719375503276188588243722655521225159899315126844306119104997283731460041142142861614319514182297180409656236066011186834375282437648078334082114411988739789392926471318552017202390239258487258487037639778148532362214152519137264282830808294108610004403460587358629486534247288993860831438267841520573973916758902637404855712721811250301202405252158590233975917681798839166192235032424495289048875626437256513981936177292903742966118351026329401662519672777610159422234703124064225710846129876359778079390437505753932101501472252131924073957349012610362952003934494293369977045255000415066563914471132856401071867358687200638320541179048296074882945411664474157308113874183763200469775985802906031999934356545932354932945475129644344782759659758587119586377699, 10811389778781749507848369001995006527965136627134898173336798777178617924322548317218123003648199959431162146218350234488676047952720517043381973357960494027353001493321216082118308994614655309535481054291078777020047697030175144901965025751169815034274454689657181813765988172412194436669592236745329922983348687, 302270795345262652787049603034608860428203534578338699389744017410286806560707153186173595970011317749221953776227374491075684575774328458397778789729965544452010822737225229627108698874874960910965283322537095645241316756015118860396297708799504427117968454341778975073542738740964812664233075630257595196115893498655587491091126391722042679460013562303363850840912825755508680428829444388842951146482726568654418889598972824414109879370032604627990857015975495697530048397401132619555923308480516678981072029040306410523264480829688927798146165580384683689546853438820269495274502502143436234210825345362323042888891473423488116618918996618482754420372481893339222050268599796400452566639228520072261554594477336671016198833620427171498256007475831231524217372147783123617237105584613811522861590112133798309937116024168109605161059186745904038968516182034441583819409524470833832445513001764653452246905494902592731421744692331296978104865554556383417129664683066891729999411036376957753554228948901872115141778394712481069999501808719302346670855531871069366050528261442730651167165455031776639195754458920584910014448480393554851269958179362536781346169282601003523441289868134223507188615919092337658908484201829621953970243126, 292884935929549246643624576832991010496540593142708150947518571090956754050658797955786741707549303442499542376031718493862827439931968289137063776270385766876597819025272388601563339731026897291119786098658019861515084557432779618732711248671531045529170282246847559014298960824095511448557742476351035447816620523706582563446012744989424367197536652910056457067991830630881476241325631891896455745762634189112349619740103725259844111996043190764424736601828139403024375351372351763169837210283497390177391509068689722596094161210899552103572279045474893618035695053640281885367691987326728488743356438444158731410968935525788220429173044772188634219137052045984284351149340419125628533953328666109489959225736888258255952666488686965689900369280599239198825803111830614815595803322570878359992207842211026468967074229662081167123002174445268278747577520774432781623852071789431202030569577689851124794177654088403580945598530502231516822280930459410373890257129917535480957183190120541342731664708767982764672591340622307503858396934095635519503588136203556304925670734741505400274178108097309035870578129722954864083937813328351751442713938490297629659866083082398939022316220801556516785394083566880368038684968532814902807429836] xp, xn = Hints[0], Hints[3] n = xn + 1 p = GCD(n, xp) q = n // p PhiN = (p - 1) * (q - 1) d = inverse_mod(e, PhiN) pt = pow(ct, d, n) return long_to_bytes(pt) Part 2: 1 2 3 4 5 6 7 8 9 10 11 def part2(): e = getPrime(10) p = getPrime(256) q = getPrime(256) n = p * q # print(e) m1 = bytes_to_long(FLAG_PART2.encode()) m2 = m1 \u0026gt;\u0026gt; 8 c1, c2 = pow(m1, e, n), pow(m2, e, n) f.write(f\u0026#34;n = {n}\\nc1 = {c1}\\nc2 = {c2}\\n\u0026#34;) Với $e$ nhỏ, thì ta nghĩ ngay tới Low public exponent attack và khi tìm hiểu thì ta thấy bài này tương đồng với kiểu Franklin–Reiter related-message attack\nCụ thể hơn, $m_2 = m _1 \u0026raquo; 8 \\Leftrightarrow m_1 = m_2 * (1 \u0026raquo; 8) + k$. Mặt khác, ta biết rằng $m_1$ là Part2 của flag tức là phần tử cuối trong 8 bit của nó khi quy về bảng mã ASCII sẽ là } tương đương với giá trị 125\n=\u0026gt; $m_1=256*m_2+125$\nSau đó, ta viết lại dưới dạng đa thức $f(x)$ và $g(x)$ là: $$ \\begin{cases} f(x) = x^e-c_1, f(m_1) =0 \\\\ g(x) = x^e-c_2, f(m_2) =0 \\end{cases} \\Leftrightarrow \\begin{cases} f(x) = (256*x+125)^e-c_1, f(m_2) =0 \\\\ g(x) = x^e-c_2, g(m_2) =0 \\end{cases} $$Hai đa thức này có nghiệm chung là $m_2$ nên khi lấy GCD của chúng và nếu nó tuyến tính thì ta sẽ lấy được $m_2$, tính $m_1$ và lấy được Part2 của flag.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def Part2(): n = 3942322022657678598973964668297464188690492529227912763243818849286024502988170927049337618748813366973108404930787214396933140242919629931061653981563183 c1 = 711628464933911477721875076362382562533209928505813633932265201230108117662370018036520970813120568151605229871541865330790006742825947411425842775387464 c2 = 199593868713063917388131306750677766968978918100656918000052209242691143624414286755644005020481267183225454134184719235765273635594459821952870709463733 def my_gcd(a, b): return a.monic() if b == 0 else my_gcd(b, a % b) x = PolynomialRing(Zmod(n), \u0026#39;x\u0026#39;).gen() for e in trange(2**9, 2**10): if not is_prime(e) or e.bit_length() != 10: continue fx = (256 * x + 125) ** e - c1 gx = x ** e - c2 sol = my_gcd(fx, gx) if sol.degree() == 1: m2 = int(-sol.coefficients()[0]) m1 = 256 * m2 + 125 return long_to_bytes(m1) Script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 # solution.py from sage.all import * from Crypto.Util.number import long_to_bytes from tqdm import trange # Part 1 def Part1(): e = 0x10001 ct = 239991743627005761506047553716973180857493049128968395824678613535924041735819278721655197652704368009118731671080782572692443257002266295841054097811995343407149181564647568019524547331554506022380795516159222363510661688595308307174873885160951837722610012918052195448795081291878933355634383798002056753336540546915811592763747343189324926404600658482137848658910189331650916354541907427173491308413908173314104508974384232290785538938623142120477030045742266779693627293755590884412082209151425384896460777577066084111556036719259982254175935197376972307183776259868229411302259648873045160120795060467866459055693698198316577983136619062944244317116994863470942099523485902299419458583301056211340627830237050622364646501838811516544340499168319955128200158195905283972429746772105746244910156671549456233908152186037286726530314472293814226978595268877619521165090870514287104577960355240428728213124348138646047728851553209042359051265045752603864312856768918350064549850618348693037041311112677351368226231458377933846664981185928405481697006968220556167073996713389716367133156065980195285148700027809062253416860922839857907535460170132744912543758918516134641462581544039400881675553681819294266618981791250077585566821053 Hints = [1659380349228980310793195740551091998951133377142727433181233112954301485314646349955561783455759149036476737520702967988760310760312391176774501840210477308343796277178701715703164651184747756453236376960884981254635386807663657355175214655034193946682205904113897156938926175413312324159809831274187894029251371896829385517428693915588566248998565348483747234270329027561433356156355227738138379418717200316600111392671357267757409316691191187929104999221832963378673907868493499459459256894553552195468110517716115678897171373484791903085022119845347228569870830569321957438966030560930098761455953418479618027428739560761186901956751224602703471828674970337530768801203531827467185690264637238603523292728974955840936711823826949100349569805942227432262275344597592991937770320032450419910426614638156263968483514069904464463402987714698220412063100772910040673056263954301063853666792319306234733964442731206579494701823, 2473062479389297534384652365580702456631745761133091301459488546735676124432184165907268360691972078275036508838070797476235444908532100862886958054816201240359777405719375503276188588243722655521225159899315126844306119104997283731460041142142861614319514182297180409656236066011186834375282437648078334082114411988739789392926471318552017202390239258487258487037639778148532362214152519137264282830808294108610004403460587358629486534247288993860831438267841520573973916758902637404855712721811250301202405252158590233975917681798839166192235032424495289048875626437256513981936177292903742966118351026329401662519672777610159422234703124064225710846129876359778079390437505753932101501472252131924073957349012610362952003934494293369977045255000415066563914471132856401071867358687200638320541179048296074882945411664474157308113874183763200469775985802906031999934356545932354932945475129644344782759659758587119586377699, 10811389778781749507848369001995006527965136627134898173336798777178617924322548317218123003648199959431162146218350234488676047952720517043381973357960494027353001493321216082118308994614655309535481054291078777020047697030175144901965025751169815034274454689657181813765988172412194436669592236745329922983348687, 302270795345262652787049603034608860428203534578338699389744017410286806560707153186173595970011317749221953776227374491075684575774328458397778789729965544452010822737225229627108698874874960910965283322537095645241316756015118860396297708799504427117968454341778975073542738740964812664233075630257595196115893498655587491091126391722042679460013562303363850840912825755508680428829444388842951146482726568654418889598972824414109879370032604627990857015975495697530048397401132619555923308480516678981072029040306410523264480829688927798146165580384683689546853438820269495274502502143436234210825345362323042888891473423488116618918996618482754420372481893339222050268599796400452566639228520072261554594477336671016198833620427171498256007475831231524217372147783123617237105584613811522861590112133798309937116024168109605161059186745904038968516182034441583819409524470833832445513001764653452246905494902592731421744692331296978104865554556383417129664683066891729999411036376957753554228948901872115141778394712481069999501808719302346670855531871069366050528261442730651167165455031776639195754458920584910014448480393554851269958179362536781346169282601003523441289868134223507188615919092337658908484201829621953970243126, 292884935929549246643624576832991010496540593142708150947518571090956754050658797955786741707549303442499542376031718493862827439931968289137063776270385766876597819025272388601563339731026897291119786098658019861515084557432779618732711248671531045529170282246847559014298960824095511448557742476351035447816620523706582563446012744989424367197536652910056457067991830630881476241325631891896455745762634189112349619740103725259844111996043190764424736601828139403024375351372351763169837210283497390177391509068689722596094161210899552103572279045474893618035695053640281885367691987326728488743356438444158731410968935525788220429173044772188634219137052045984284351149340419125628533953328666109489959225736888258255952666488686965689900369280599239198825803111830614815595803322570878359992207842211026468967074229662081167123002174445268278747577520774432781623852071789431202030569577689851124794177654088403580945598530502231516822280930459410373890257129917535480957183190120541342731664708767982764672591340622307503858396934095635519503588136203556304925670734741505400274178108097309035870578129722954864083937813328351751442713938490297629659866083082398939022316220801556516785394083566880368038684968532814902807429836] xp, xn = Hints[0], Hints[3] n = xn + 1 p = GCD(n, xp) q = n // p PhiN = (p - 1) * (q - 1) d = inverse_mod(e, PhiN) pt = pow(ct, d, n) return long_to_bytes(pt) #Part 2 def Part2(): n = 3942322022657678598973964668297464188690492529227912763243818849286024502988170927049337618748813366973108404930787214396933140242919629931061653981563183 c1 = 711628464933911477721875076362382562533209928505813633932265201230108117662370018036520970813120568151605229871541865330790006742825947411425842775387464 c2 = 199593868713063917388131306750677766968978918100656918000052209242691143624414286755644005020481267183225454134184719235765273635594459821952870709463733 def my_gcd(a, b): return a.monic() if b == 0 else my_gcd(b, a % b) x = PolynomialRing(Zmod(n), \u0026#39;x\u0026#39;).gen() for e in trange(2**9, 2**10): if not is_prime(e) or e.bit_length() != 10: continue fx = (256 * x + 125) ** e - c1 gx = x ** e - c2 sol = my_gcd(fx, gx) if sol.degree() == 1: m2 = int(-sol.coefficients()[0]) m1 = 256 * m2 + 125 return long_to_bytes(m1) if __name__ == \u0026#34;__main__\u0026#34;: PART1 = Part1() PART2 = Part2() flag = PART1 + PART2 print(flag.decode()) Flag: W1{https://www.youtube.com/results?search_query=p0lyn0m1als+9c4+is+good+isn%27t+it+?flag=tru4} ","date":"2025-05-16T14:13:38+07:00","image":"https://r1muru2006.github.io/p/wannagame-cyber-knight-2025/w1cyber_hu_f46845bbc2d26b62.png","permalink":"https://r1muru2006.github.io/p/wannagame-cyber-knight-2025/","title":"WannaGame Cyber Knight 2025"},{"content":"Pwn 1. Hello pwner Flag: W1{welcome_to_assembly} Crypto 2. Substitution Tải file, giải nén và mở chall lên:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 KEY = { \u0026#39;A\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;D\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;E\u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;F\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#39;G\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;H\u0026#39;: \u0026#39;I\u0026#39;, \u0026#39;I\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;J\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;K\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;L\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;M\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;N\u0026#39;: \u0026#39;F\u0026#39;, \u0026#39;O\u0026#39;: \u0026#39;G\u0026#39;, \u0026#39;P\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;Q\u0026#39;: \u0026#39;J\u0026#39;, \u0026#39;R\u0026#39;: \u0026#39;K\u0026#39;, \u0026#39;S\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;T\u0026#39;: \u0026#39;Z\u0026#39;, \u0026#39;U\u0026#39;: \u0026#39;X\u0026#39;, \u0026#39;V\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;W\u0026#39;: \u0026#39;V\u0026#39;, \u0026#39;X\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;Y\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;Z\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;a\u0026#39;: \u0026#39;q\u0026#39;, \u0026#39;b\u0026#39;: \u0026#39;w\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;: \u0026#39;r\u0026#39;, \u0026#39;e\u0026#39;: \u0026#39;t\u0026#39;, \u0026#39;f\u0026#39;: \u0026#39;y\u0026#39;, \u0026#39;g\u0026#39;: \u0026#39;u\u0026#39;, \u0026#39;h\u0026#39;: \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;: \u0026#39;o\u0026#39;, \u0026#39;j\u0026#39;: \u0026#39;p\u0026#39;, \u0026#39;k\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;l\u0026#39;: \u0026#39;s\u0026#39;, \u0026#39;m\u0026#39;: \u0026#39;d\u0026#39;, \u0026#39;n\u0026#39;: \u0026#39;f\u0026#39;, \u0026#39;o\u0026#39;: \u0026#39;g\u0026#39;, \u0026#39;p\u0026#39;: \u0026#39;h\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;j\u0026#39;, \u0026#39;r\u0026#39;: \u0026#39;k\u0026#39;, \u0026#39;s\u0026#39;: \u0026#39;l\u0026#39;, \u0026#39;t\u0026#39;: \u0026#39;z\u0026#39;, \u0026#39;u\u0026#39;: \u0026#39;x\u0026#39;, \u0026#39;v\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;w\u0026#39;: \u0026#39;v\u0026#39;, \u0026#39;x\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;y\u0026#39;: \u0026#39;n\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;m\u0026#39;, } def hehe(data, key): return \u0026#39;\u0026#39;.join(key.get(char, char) for char in data) def encrypt(plaintext): substituted = hehe(plaintext, KEY) return substituted if __name__ == \u0026#34;__main__\u0026#34;: plaintext = \u0026#34;W1{???????????????}\u0026#34; encrypted = encrypt(plaintext) with open(\u0026#34;encrypted.txt\u0026#34;, \u0026#34;w\u0026#34;) as f: f.write(encrypted) Phân tích: 1 2 def hehe(data, key): return \u0026#39;\u0026#39;.join(key.get(char, char) for char in data) Hàm hehe lấy data và chuyển đổi từng ký tự trong dữ liệu đó sang ký tự tương ứng bằng danh sách của KEY.\n1 2 3 def encrypt(plaintext): substituted = hehe(plaintext, KEY) return substituted Hàm encrypt có mục đich là sử dụng hàm hehe để mã hóa dữ liệu. Giải: Để lấy được plaintext thì ta cần giải mã encrypted, nghĩa là phải đảo ngược lại quá trình chuyển đổi ký tự trong danh sách của KEY\n1 KEY_rev = {i : v for v, i in KEY.items()} Rồi sử dụng hàm hehe chuyển đổi tiếp 1 lần nữa để được data ban đầu.\n1 2 def hehe(data, key): return \u0026#39;\u0026#39;.join(key.get(char, char) for char in data) Script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 KEY = { \u0026#39;A\u0026#39;: \u0026#39;Q\u0026#39;, \u0026#39;B\u0026#39;: \u0026#39;W\u0026#39;, \u0026#39;C\u0026#39;: \u0026#39;E\u0026#39;, \u0026#39;D\u0026#39;: \u0026#39;R\u0026#39;, \u0026#39;E\u0026#39;: \u0026#39;T\u0026#39;, \u0026#39;F\u0026#39;: \u0026#39;Y\u0026#39;, \u0026#39;G\u0026#39;: \u0026#39;U\u0026#39;, \u0026#39;H\u0026#39;: \u0026#39;I\u0026#39;, \u0026#39;I\u0026#39;: \u0026#39;O\u0026#39;, \u0026#39;J\u0026#39;: \u0026#39;P\u0026#39;, \u0026#39;K\u0026#39;: \u0026#39;A\u0026#39;, \u0026#39;L\u0026#39;: \u0026#39;S\u0026#39;, \u0026#39;M\u0026#39;: \u0026#39;D\u0026#39;, \u0026#39;N\u0026#39;: \u0026#39;F\u0026#39;, \u0026#39;O\u0026#39;: \u0026#39;G\u0026#39;, \u0026#39;P\u0026#39;: \u0026#39;H\u0026#39;, \u0026#39;Q\u0026#39;: \u0026#39;J\u0026#39;, \u0026#39;R\u0026#39;: \u0026#39;K\u0026#39;, \u0026#39;S\u0026#39;: \u0026#39;L\u0026#39;, \u0026#39;T\u0026#39;: \u0026#39;Z\u0026#39;, \u0026#39;U\u0026#39;: \u0026#39;X\u0026#39;, \u0026#39;V\u0026#39;: \u0026#39;C\u0026#39;, \u0026#39;W\u0026#39;: \u0026#39;V\u0026#39;, \u0026#39;X\u0026#39;: \u0026#39;B\u0026#39;, \u0026#39;Y\u0026#39;: \u0026#39;N\u0026#39;, \u0026#39;Z\u0026#39;: \u0026#39;M\u0026#39;, \u0026#39;a\u0026#39;: \u0026#39;q\u0026#39;, \u0026#39;b\u0026#39;: \u0026#39;w\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;e\u0026#39;, \u0026#39;d\u0026#39;: \u0026#39;r\u0026#39;, \u0026#39;e\u0026#39;: \u0026#39;t\u0026#39;, \u0026#39;f\u0026#39;: \u0026#39;y\u0026#39;, \u0026#39;g\u0026#39;: \u0026#39;u\u0026#39;, \u0026#39;h\u0026#39;: \u0026#39;i\u0026#39;, \u0026#39;i\u0026#39;: \u0026#39;o\u0026#39;, \u0026#39;j\u0026#39;: \u0026#39;p\u0026#39;, \u0026#39;k\u0026#39;: \u0026#39;a\u0026#39;, \u0026#39;l\u0026#39;: \u0026#39;s\u0026#39;, \u0026#39;m\u0026#39;: \u0026#39;d\u0026#39;, \u0026#39;n\u0026#39;: \u0026#39;f\u0026#39;, \u0026#39;o\u0026#39;: \u0026#39;g\u0026#39;, \u0026#39;p\u0026#39;: \u0026#39;h\u0026#39;, \u0026#39;q\u0026#39;: \u0026#39;j\u0026#39;, \u0026#39;r\u0026#39;: \u0026#39;k\u0026#39;, \u0026#39;s\u0026#39;: \u0026#39;l\u0026#39;, \u0026#39;t\u0026#39;: \u0026#39;z\u0026#39;, \u0026#39;u\u0026#39;: \u0026#39;x\u0026#39;, \u0026#39;v\u0026#39;: \u0026#39;c\u0026#39;, \u0026#39;w\u0026#39;: \u0026#39;v\u0026#39;, \u0026#39;x\u0026#39;: \u0026#39;b\u0026#39;, \u0026#39;y\u0026#39;: \u0026#39;n\u0026#39;, \u0026#39;z\u0026#39;: \u0026#39;m\u0026#39;, } KEY_rev = {i : v for v, i in KEY.items()} def hehe(data, key): return \u0026#34;\u0026#34;.join(key.get(char, char) for char in data) def decrypt(plaintext): substituted = hehe(plaintext, KEY_rev) return substituted if __name__ == \u0026#34;__main__\u0026#34;: encrypted = \u0026#34;V1{lxwlzozxzogf}\u0026#34; decrypted = decrypt(encrypted) print(decrypted) Flag: W1{substitution} 3. Hix Tải file, giải nén và mở chall lên:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 import hashlib import random methods = [\u0026#39;md5\u0026#39;, \u0026#39;sha256\u0026#39;, \u0026#39;sha3_256\u0026#39;, \u0026#39;sha3_512\u0026#39;, \u0026#39;sha3_384\u0026#39;, \u0026#39;sha1\u0026#39;, \u0026#39;sha384\u0026#39;, \u0026#39;sha3_224\u0026#39;, \u0026#39;sha512\u0026#39;, \u0026#39;sha224\u0026#39;] def random_encrypt(x) : method = random.choice(methods) hash_obj = hashlib.new(method) hash_obj.update(x.encode()) return hash_obj.hexdigest() def main() : message = open(\u0026#34;./../private/flag.txt\u0026#34;, \u0026#34;r\u0026#34;).read() enc = [] for char in message : x = (ord(char) + 20) % 130 x = hashlib.sha512(str(x).encode()).hexdigest() x = random_encrypt(x) enc.append(x) with open(\u0026#39;encrypted_memory.txt\u0026#39;, \u0026#39;w\u0026#39;) as f : f.write(\u0026#34;ct = \u0026#34; + str(enc)) if __name__ == \u0026#34;__main__\u0026#34; : main() Phân tích: 1 methods = [\u0026#39;md5\u0026#39;, \u0026#39;sha256\u0026#39;, \u0026#39;sha3_256\u0026#39;, \u0026#39;sha3_512\u0026#39;, \u0026#39;sha3_384\u0026#39;, \u0026#39;sha1\u0026#39;, \u0026#39;sha384\u0026#39;, \u0026#39;sha3_224\u0026#39;, \u0026#39;sha512\u0026#39;, \u0026#39;sha224\u0026#39;] Đây là các thuật toán được sử dụng cho hàm băm.\n1 2 3 4 5 def random_encrypt(x) : method = random.choice(methods) hash_obj = hashlib.new(method) hash_obj.update(x.encode()) return hash_obj.hexdigest() Hàm random_encrypt dùng để mã hóa một chuỗi x bằng cách sử dụng một thuật toán băm bất kì có sẵn trong methods.\n1 2 3 4 5 for char in message : x = (ord(char) + 20) % 130 x = hashlib.sha512(str(x).encode()).hexdigest() x = random_encrypt(x) enc.append(x) Lấy từng kí tự trong message, sau đó lấy giá trị của ký tự đó trong ASCII rồi cộng 20 và lấy modulo 130. Tiếp theo, chuyển nó về một chuỗi rồi băm bằng SHA-512. Đến cuối thì sử dụng hàm random_encrypt. Giải: Ý tưởng: Vì x nằm trong đoạn từ 0 đến 129 (là một số nhỏ) nên ta có thể brute-force từng giá trị x khi thử với mỗi phương pháp băm để tìm ra các x tương ứng với từng giá trị của ct một cách dễ dàng.\n1 2 3 4 5 6 7 8 9 10 11 def reverse_encrypt(enc_hash): for method in methods: try: for x in range(130): test_input = hashlib.sha512(str(x).encode()).hexdigest() hash_obj = hashlib.new(method) hash_obj.update(test_input.encode()) if hash_obj.hexdigest() == enc_hash: return x except: continue Sau đó, với từng giá trị trong ct, ta dùng hàm reverse_encrypt và truy ngược lại giá trị x ban đầu bằng các phép toán và đổi sang dạng ASCII để giải mã nó bằng hàm sau:\n1 2 3 4 5 6 7 def decrypt(): decrypted_message = \u0026#34;\u0026#34; for ct_hash in ct: x = reverse_encrypt(ct_hash) original_ascii = (x - 20) % 130 decrypted_message += chr(original_ascii) return decrypted_message Script:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ct = [\u0026#39;f189636f8eef640b55d03387864fd17efd324453cc9276be5ff6bd4da88b13fca72438daaab00830a6d14330d37c0f7bee1e7c32d5dda0541a171f66a2343dc1\u0026#39;, \u0026#39;1388cafa58065fa0c04372ce57f303cc4ec9fe62\u0026#39;, \u0026#39;f6266e2849bf8b8575701814cc3f3eb5369e887db54b34e85b1e4608b4fbf5e5\u0026#39;, \u0026#39;31f33ac191e818db784cf8321d70f84763db2b2e599f90cf65868eec85a10f20ae0e23aa1cd48c2f13eec355b2975089490761a291ac2a1bcf33f5fbecead431\u0026#39;, \u0026#39;981e4bce5dede3faa51a936f650e2c1d64169493860c67d68a1ffbbfa32f58598e7869f3f11aefc1620ee8d3ebe4e5f5\u0026#39;, \u0026#39;f06ffaaa6290bf47d26ba2c09c28dddd8f5bcad6ac464ec17fea48040acf1214d10bc109b7c47cffddb6bccd6b61b61a9e629a8f47ab26b80593f29c8c297489\u0026#39;, \u0026#39;a7d95b3bbde885b4eaa76afc6572e18e4483351005f637fe1f5a7bc0b000fe1f\u0026#39;, \u0026#39;85245de371c327440a5f343f27d6df361225806e679950bab3a5a336\u0026#39;, \u0026#39;ea1923e909de3c3c3384ad9ae7696d73\u0026#39;, \u0026#39;21df20aab35967470aada32375f535d4a735789bf0789fd421f85163c4d75c6e\u0026#39;, \u0026#39;b9491ae1a9de40d30a86c00139bd7d6f496f5bf4ce013bc2d5a43a97\u0026#39;, \u0026#39;03f061f60f3527b15ff31d31dcce0761\u0026#39;, \u0026#39;981e4bce5dede3faa51a936f650e2c1d64169493860c67d68a1ffbbfa32f58598e7869f3f11aefc1620ee8d3ebe4e5f5\u0026#39;, \u0026#39;f2a1a7e9dd5e6363050b0cdb0579ebfebdc5e348ab538bdcf47616139351cf2b9f92cb4d14446b3ad8bf182875b81e75\u0026#39;, \u0026#39;24aaafc58a2b897aed5829b2e96d73b1de7cd680d76a1143cdc8baef\u0026#39;, \u0026#39;6d80d11e5f1161ef86619dcdb186852b5218d6ac224b81b63555fe73741631c36ae0bcb5b3228fbed796c22dedeed587c9d65ddb825aee4fae92b6619e7ffd8f\u0026#39;, \u0026#39;6f8b39550106044625102ee0cabf9fe1393f0013388633d5742fcc7e8df7708793a96885b9d18b795a2b0d9014704b9f\u0026#39;, \u0026#39;ddf3c543be9cac44f3af078583fe5fddb64104d93308c146c23f52ff25b2a6e23606c42dc0060a4dd9b11b446759cb5de1844471eb3d6d25c43c6fcc0d8d60c4\u0026#39;, \u0026#39;95f2739053cf64555b0c0662b5e2d63822433f7fcac6960de6d57efda427461a58c6e2ffac6da6f4caa9407df10cc0be\u0026#39;, \u0026#39;a1bd4e0efc7ce8bd1d63433a0baa87e3a486fbfe2729d73d1dbf7d2822d201ee8726c6d94da1f09f1a53554e440ad6041ecab545b2085dc28c6f6849f0fcea23\u0026#39;, \u0026#39;a7d95b3bbde885b4eaa76afc6572e18e4483351005f637fe1f5a7bc0b000fe1f\u0026#39;, \u0026#39;2b4561a521a82af6a26dfb76078ca97ba53a720f7ee67d923a6d3a13\u0026#39;, \u0026#39;b21ed1f3d501a8a842ef1b26ed3863cf10cf8231ee23a079f749cfa322702c8e\u0026#39;, \u0026#39;d798a32b52384219f8779dccf8b2173f4b73f075cbeb4507ee83c94e\u0026#39;, \u0026#39;b863fa3492fb87edcdef766f38a508ed\u0026#39;, \u0026#39;9f876db4b58c1b7e499f35cdbd533a810060a0c8250bfc5421e0f42b2715b027\u0026#39;, \u0026#39;4b14748ba0f3da581ddd7ec49dac41d34ea1ee6dae90818333b11501\u0026#39;, \u0026#39;85153b2a5f8dea7f5488906cb65d61e9ac0666057636ff6b356dd4d8d0fc5d20\u0026#39;, \u0026#39;6b91d6259827176bcb3f312a8faca297e56c7e627235b930cf8163b3e7a5328b\u0026#39;, \u0026#39;b21ed1f3d501a8a842ef1b26ed3863cf10cf8231ee23a079f749cfa322702c8e\u0026#39;, \u0026#39;4c8740f90af1055f194a4c8e1b69522da228812465eb72b82b35c927bc48bf9d\u0026#39;, \u0026#39;b248b6b2f2c9365aa9a0e9b37a8057effd29bb2f34c79ec0b40124d08986832b5d227db95cb97b176541589985762d9a\u0026#39;, \u0026#39;7260f9b5d1c58d0609523114ed324f396335d940f852dba558461b34c5a53630\u0026#39;, \u0026#39;a1bd4e0efc7ce8bd1d63433a0baa87e3a486fbfe2729d73d1dbf7d2822d201ee8726c6d94da1f09f1a53554e440ad6041ecab545b2085dc28c6f6849f0fcea23\u0026#39;, \u0026#39;1077caf3ed754ed8fbd49c76134906e8\u0026#39;, \u0026#39;f3565219d115ec74a85056997cc25e98e3e4912a31c858c1e45b841047698e93\u0026#39;, \u0026#39;83315b8fa07a35b12e3f47ebb365268b4a4a8ef2\u0026#39;, \u0026#39;64c008d6460c2b98aba616b1d0d11a06b9df564b87d3aeedda83b36aacd3d0c160465109eb06c62e86e360cf026faa27a616dbbf2bec269be9ad128af96073bb\u0026#39;, \u0026#39;60bbd94b3ac3ea7149fc6cd850d72d4f1750601275832815dd9a23d4c3757d84aca29d716da5dd72a0045f15ff969925\u0026#39;, \u0026#39;94327e8c8321421e72f52cd726336e824630ec7dda31b07ce83f11b8234aea7a\u0026#39;, \u0026#39;a69ef62254280226cc4223a2341c727afcd7ce4e3ffd3f2f1c57d9d3cd30659b52b1c2b56f911a7157041b5f0ff8176f\u0026#39;, \u0026#39;3c904622c8d8d79c6704d50ae0175b049b3a5708705ecdce932fe426b9f46f1bd6585b8288c1d38f6301c31af5feac02\u0026#39;, \u0026#39;a3939bf491ffd9824056e249d6e355d8423855f0\u0026#39;] import hashlib methods = [\u0026#39;md5\u0026#39;, \u0026#39;sha256\u0026#39;, \u0026#39;sha3_256\u0026#39;, \u0026#39;sha3_512\u0026#39;, \u0026#39;sha3_384\u0026#39;, \u0026#39;sha1\u0026#39;, \u0026#39;sha384\u0026#39;, \u0026#39;sha3_224\u0026#39;, \u0026#39;sha512\u0026#39;, \u0026#39;sha224\u0026#39;] def reverse_encrypt(enc_hash): for method in methods: try: for x in range(130): test_input = hashlib.sha512(str(x).encode()).hexdigest() hash_obj = hashlib.new(method) hash_obj.update(test_input.encode()) if hash_obj.hexdigest() == enc_hash: return x except: continue def decrypt(): decrypted_message = \u0026#34;\u0026#34; for ct_hash in ct: x = reverse_encrypt(ct_hash) original_ascii = (x - 20) % 130 decrypted_message += chr(original_ascii) return decrypted_message if __name__ == \u0026#34;__main__\u0026#34;: flag = decrypt() print(flag) Flag: W1{are_you_trying_to_predict_randomness@_@} 4. DH Tải file, giải nén và mở chall lên:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 from Crypto.Util.number import isPrime, long_to_bytes, getPrime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from random import randint from hashlib import sha256 FLAG = b\u0026#34;W1{fake-flag}\u0026#34; class DH: def __init__(self): self.gen_params() def gen_params(self): self.r = getPrime(512) while True: self.q = getPrime(42) self.p = (2 * self.q * self.r) + 1 if isPrime(self.p): break while True: self.h = getPrime(42) self.g = pow(self.h, 2 * self.r, self.p) if self.g != 1: break self.a = randint(2, self.p - 2) self.b = randint(2, self.p - 2) self.A, self.B = pow(self.g, self.a, self.p), pow(self.g, self.b, self.p) self.ss = pow(self.A, self.b, self.p) def encrypt(self, flag_part): key = sha256(long_to_bytes(self.ss)).digest()[:16] cipher = AES.new(key, AES.MODE_ECB) ct = cipher.encrypt(pad(flag_part, 16)).hex() return f\u0026#34;encrypted = {ct}\u0026#34; def get_params(self): return f\u0026#34;p = {self.p}\\ng = {self.g}\\nA = {self.A}\\nB = {self.B}\u0026#34; def main(): dh = DH() print(dh.get_params()) print(dh.encrypt(FLAG)) if __name__ == \u0026#34;__main__\u0026#34;: main() p = 85013941328859365232686230728938372320812319905627686919070637645614632817039920673725615375841158719310596592903101914818137738460649589340349796188816568005092757847 g = 20033344683527080232439150682925185454003164954955126339094967675384779782733210350757021743656898625398860187361281262413493941502725149445995471514781822892886669776 A = 76548721461171533747911417838852759206858825205673491250696441734297318615226024320798706656529038703728631231084155790148283919370554345818139818854112841655270107839 B = 2103083080159597422706551446020625757109756570951674830166998494220734179439318911618156966499109201221652320384817270671579741987575328177442670242481963924501204498 encrypted = \u0026#34;240e7b7678aaaa0dcbe06de7c5598a1ca0be7e2ae584bc7dfd2388cdb1d4fb6a37ceb94556757afc293999cbe5a5a2dbb4071ebf6cfd4332088555f9b2de1922\u0026#34; Phân tích: Trong class DH, có:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 def gen_params(self): self.r = getPrime(512) while True: self.q = getPrime(42) self.p = (2 * self.q * self.r) + 1 if isPrime(self.p): break while True: self.h = getPrime(42) self.g = pow(self.h, 2 * self.r, self.p) if self.g != 1: break self.a = randint(2, self.p - 2) self.b = randint(2, self.p - 2) self.A, self.B = pow(self.g, self.a, self.p), pow(self.g, self.b, self.p) self.ss = pow(self.A, self.b, self.p) Hàm gen_params tạo một bộ khóa Diffie-Hellman.\n1 2 def get_params(self): return f\u0026#34;p = {self.p}\\ng = {self.g}\\nA = {self.A}\\nB = {self.B}\u0026#34; Khi lấy hàm get_params thì sẽ trả về các giá trị p, g, A, B.\n1 2 3 4 5 def encrypt(self, flag_part): key = sha256(long_to_bytes(self.ss)).digest()[:16] cipher = AES.new(key, AES.MODE_ECB) ct = cipher.encrypt(pad(flag_part, 16)).hex() return f\u0026#34;encrypted = {ct}\u0026#34; Ngoài ra, còn có hàm encrypt lấy giá trị ss từ hàm gen_params để tạo key cho thuật toán mã hóa AES chế độ ECB, cuối cùng dùng nó để mã hóa FLAG.\nGiải: Để tìm ra FLAG thì ta cần lấy được key để giải mã cipher\n1 2 3 key = sha256(long_to_bytes(ss)).digest()[:16] cipher = AES.new(key, AES.MODE_ECB) flag = cipher.decrypt(encrypted) Do đó, ta phải tìm ra giá trị ss để tạo được key. Ta có các phương trình sau:\n$A≡g^a$ (mod p); $B≡g^b$ $⇒ss≡A^b≡(g^a )^b≡g^{ab}≡(g^b )^a≡B^a$ (mod p)\nTa đã có p, g, A, vậy ta chỉ cần có thêm b là có thể tìm ra ss. Tới đây, tôi sử dụng thuật toán Pohlig-Hellman để tìm b qua công thức $B≡g^b$ (mod p) bằng công cụ Alpetron.\nSet k = 0, lấy được b = exp và tính được ss. Sau đây là script cho thử thách:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from Crypto.Util.number import long_to_bytes from Crypto.Cipher import AES from hashlib import sha256 p = 85013941328859365232686230728938372320812319905627686919070637645614632817039920673725615375841158719310596592903101914818137738460649589340349796188816568005092757847 g = 20033344683527080232439150682925185454003164954955126339094967675384779782733210350757021743656898625398860187361281262413493941502725149445995471514781822892886669776 A = 76548721461171533747911417838852759206858825205673491250696441734297318615226024320798706656529038703728631231084155790148283919370554345818139818854112841655270107839 B = 2103083080159597422706551446020625757109756570951674830166998494220734179439318911618156966499109201221652320384817270671579741987575328177442670242481963924501204498 encrypted = \u0026#34;240e7b7678aaaa0dcbe06de7c5598a1ca0be7e2ae584bc7dfd2388cdb1d4fb6a37ceb94556757afc293999cbe5a5a2dbb4071ebf6cfd4332088555f9b2de1922\u0026#34; encrypted = bytes.fromhex(encrypted) b = 2891401095038 ss = pow(A, b, p) key = sha256(long_to_bytes(ss)).digest()[:16] cipher = AES.new(key, AES.MODE_ECB) flag = cipher.decrypt(encrypted) print(flag.decode()) Flag: W1{so_you_know_about_the_Diffie-Hellman-key_exchange} Reverse 5. GiacMoTrua2 Tải file về và phiên dịch mã giả bằng IDA, ta có:\nChương trình yêu cầu ta nhập một chuỗi bí mật và đem chuỗi đó so sánh với flag sau khi qua hàm Lookthis được mã hóa thành: \u0026ldquo;W1{live_speels_a5_NoOn_4v4ry_emit!}\u0026rdquo;\nHàm swap dùng để đổi hai kí tự cho nhau. Hàm Lookthis có 3 vòng lặp riêng biệt trên từng khoảng với nhiệm vụ đổi ký tự tương ứng. Như vậy, ta chỉ cần viết script đảo ngược lại và đổi ký tự thì sẽ cho ra được flag ban đầu:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def reverse_lookthis(flag): for k in range(32, 28, -1): if k \u0026lt; (61 - k): flag[k], flag[61 - k] = flag[61 - k], flag[k] for j in range(13, 7, -1): if j \u0026lt; (21 - j): flag[j], flag[21 - j] = flag[21 - j], flag[j] for i in range(6, 2, -1): if i \u0026lt; (9 - i): flag[i], flag[9 - i] = flag[9 - i], flag[i] return flag fake_flag = [ord(c) for c in \u0026#34;W1{live_speels_a5_NoOn_4v4ry_emit!}\u0026#34;] real_flag = reverse_lookthis(fake_flag) flag = \u0026#34;\u0026#34;.join(chr(c) for c in real_flag) print(flag) Flag: W1{evil_sleeps_a5_NoOn_4v4ry_time!} 6. Easy Flag Checker Tải file và phiên dịch mã giả bằng IDA, có:\nQua hàm main, chương trình yêu cầu ta nhập một chuỗi 20 ký tự, sau đó thực hiện vòng lặp kiểm tra với mỗi ký tự thứ 4*i+32 XOR với 0x38. Sau đó lấy ký tự đó so sánh ngay với dword_4020 thứ i. Chúng ta sẽ truy cập thử vào dword_4020:\nỞ đây, các giá trị trong unk_4020 là các byte đã được mã hóa. Do đó, ta sẽ lấy các giá trị khác 0 để thực hiện phép XOR và nối lại tạo thành flag.\nSau đây là script cho thử thách:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 def reverse_lookthis(flag): for k in range(32, 28, -1): if k \u0026lt; (61 - k): flag[k], flag[61 - k] = flag[61 - k], flag[k] for j in range(13, 7, -1): if j \u0026lt; (21 - j): flag[j], flag[21 - j] = flag[21 - j], flag[j] for i in range(6, 2, -1): if i \u0026lt; (9 - i): flag[i], flag[9 - i] = flag[9 - i], flag[i] return flag fake_flag = [ord(c) for c in \u0026#34;W1{live_speels_a5_NoOn_4v4ry_emit!}\u0026#34;] real_flag = reverse_lookthis(fake_flag) flag = \u0026#34;\u0026#34;.join(chr(c) for c in real_flag) print(flag) Flag: W1{v3ry_34sy_r1gh7?} 7. GiacMoTrua1 Ta thấy tệp thử thách có định dạng .pyc. Sau khi thử tìm kiếm thì tôi biết được đây là một tệp đầu ra được biên dịch được tạo từ mã nguồn được viết bằng ngôn ngữ lập trình Python. Do đó tôi sử dụng PyLingual – một công cụ online để dịch ngược và khôi phục mã nguồn Python:\nTải file python này về, ta nhận được thử thách như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 dic = [0] * 85 dic[0] = 33 dic[1] = 35 dic[2] = 36 dic[3] = 37 dic[4] = 38 dic[5] = 40 dic[6] = 41 dic[7] = 42 dic[8] = 43 dic[9] = 44 dic[10] = 45 dic[11] = 46 dic[12] = 47 dic[13] = 48 dic[14] = 49 dic[15] = 50 dic[16] = 51 dic[17] = 52 dic[18] = 53 dic[19] = 54 dic[20] = 55 dic[21] = 56 dic[22] = 57 dic[23] = 58 dic[24] = 59 dic[25] = 60 dic[26] = 61 dic[27] = 62 dic[28] = 63 dic[29] = 64 dic[30] = 65 dic[31] = 66 dic[32] = 67 dic[33] = 68 dic[34] = 69 dic[35] = 70 dic[36] = 71 dic[37] = 72 dic[38] = 73 dic[39] = 74 dic[40] = 75 dic[41] = 76 dic[42] = 77 dic[43] = 78 dic[44] = 79 dic[45] = 80 dic[46] = 81 dic[47] = 82 dic[48] = 83 dic[49] = 84 dic[50] = 85 dic[51] = 86 dic[52] = 87 dic[53] = 88 dic[54] = 89 dic[55] = 90 dic[56] = 91 dic[57] = 97 dic[58] = 98 dic[59] = 99 dic[60] = 100 dic[61] = 101 dic[62] = 102 dic[63] = 103 dic[64] = 104 dic[65] = 105 dic[66] = 106 dic[67] = 107 dic[68] = 108 dic[69] = 109 dic[70] = 110 dic[71] = 111 dic[72] = 112 dic[73] = 113 dic[74] = 114 dic[75] = 115 dic[76] = 116 dic[77] = 117 dic[78] = 118 dic[79] = 119 dic[80] = 120 dic[81] = 121 dic[82] = 122 dic[83] = 123 dic[84] = 125 flag = input(\u0026#34;Let me help you check your flag: \u0026#34;) length = len(flag) ans = [0] * length * 2 for i in range(length): ans[i] = dic[ord(flag[i]) ^ 112] for i in range(length, length * 2): ans[i] = ans[i - length] fin = \u0026#34;\u0026#34; for i in range((23 * length + 16) % length, (23 * length + 16) % length + length): fin += chr(ans[i]) if fin == \u0026#34;R8Abq,R\u0026amp;;j%R6;kiiR%hR@k6iy0Ji.[k!8R,kHR*i??\u0026#34;: print(\u0026#34;Rightttt!\u0026#34;) print(\u0026#34;Heyy you are really lovely, i promise!\u0026#34;) else: print(\u0026#34;Think more....\u0026#34;) Phân tích: Flag được nhập vào và qua một số bước biến đổi trở thành một đoạn mã hóa cho trước là: “R8Abq,R\u0026amp;;j%R6;kiiR%hR@k6iy0Ji.[k!8R,kHR*i??” Đầu tiên, chúng ta lấy từng giá trị của flag dạng thập phân ở hệ Unicode để XOR với 112 rồi lấy đó làm chỉ số để tra bảng dic và gán vào dãy ans, tiếp theo lấy ans thêm vào sau để tạo thành 1 dãy có độ dài gấp đôi flag.\n1 2 3 4 for i in range(length): ans[i] = dic[ord(flag[i]) ^ 112] for i in range(length, length * 2): ans[i] = ans[i - length] Sau đó lập thành dãy fin mà ta đã biết trước bằng cách lấy i trong khoảng từ (23*length+16) % length tới (23*length+16) % length + length và lấy đó làm chỉ số với ans để chuyển nó về dạng Unicode và thêm vào fin.\n1 2 3 fin = \u0026#34;\u0026#34; for i in range((23 * length + 16) % length, (23 * length + 16) % length + length): fin += chr(ans[i]) Giải: Nhận thấy, fin có độ dài bằng length và lớn hơn 16 nên: $23×length+16≡16$ (mod length)\nDo đó, ans sẽ được tính từ chỉ số 16 của fin tăng dần và quay ngược lên 15. Sau đó, ta phải đảo ngược bảng giá trị dic cùng với việc thực hiện phép XOR với 112 để truy ngược lại giá trị ban đầu của flag.\nĐây là script cho thử thách:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 dic = [0] * 85 dic[0] = 33 dic[1] = 35 dic[2] = 36 dic[3] = 37 dic[4] = 38 dic[5] = 40 dic[6] = 41 dic[7] = 42 dic[8] = 43 dic[9] = 44 dic[10] = 45 dic[11] = 46 dic[12] = 47 dic[13] = 48 dic[14] = 49 dic[15] = 50 dic[16] = 51 dic[17] = 52 dic[18] = 53 dic[19] = 54 dic[20] = 55 dic[21] = 56 dic[22] = 57 dic[23] = 58 dic[24] = 59 dic[25] = 60 dic[26] = 61 dic[27] = 62 dic[28] = 63 dic[29] = 64 dic[30] = 65 dic[31] = 66 dic[32] = 67 dic[33] = 68 dic[34] = 69 dic[35] = 70 dic[36] = 71 dic[37] = 72 dic[38] = 73 dic[39] = 74 dic[40] = 75 dic[41] = 76 dic[42] = 77 dic[43] = 78 dic[44] = 79 dic[45] = 80 dic[46] = 81 dic[47] = 82 dic[48] = 83 dic[49] = 84 dic[50] = 85 dic[51] = 86 dic[52] = 87 dic[53] = 88 dic[54] = 89 dic[55] = 90 dic[56] = 91 dic[57] = 97 dic[58] = 98 dic[59] = 99 dic[60] = 100 dic[61] = 101 dic[62] = 102 dic[63] = 103 dic[64] = 104 dic[65] = 105 dic[66] = 106 dic[67] = 107 dic[68] = 108 dic[69] = 109 dic[70] = 110 dic[71] = 111 dic[72] = 112 dic[73] = 113 dic[74] = 114 dic[75] = 115 dic[76] = 116 dic[77] = 117 dic[78] = 118 dic[79] = 119 dic[80] = 120 dic[81] = 121 dic[82] = 122 dic[83] = 123 dic[84] = 125 fin = \u0026#34;R8Abq,R\u0026amp;;j%R6;kiiR%hR@k6iy0Ji.[k!8R,kHR*i??\u0026#34; length = len(fin) ans = [ord(fin[i - 16]) for i in range(length)] reverse_dic = {v: i for i, v in enumerate(dic)} flag = \u0026#34;\u0026#34;.join(chr(reverse_dic[ans[i]] ^ 112) for i in range(length)) print(flag) Flag: W1{H3pe_y3U_w1ll_enJ9y_th2s_ch311_s0_m3c1!} ","date":"2025-04-08T10:07:31+07:00","permalink":"https://r1muru2006.github.io/p/wannagame-nmlt/","title":"WannaGame NMLT"},{"content":"Misc bcu-binding Tải file về thì ta search thử \u0026lsquo;dice{\u0026rsquo; để tìm flag và nó ra thật @@ Có vẻ như nó được giấu trong phần nền trắng để không thể nhìn thấy\u0026hellip;\nFlag: dice{r3ad1ng_th4_d0cs_71ccd} dicecap Đề cho ta 1 file pcap nên ta mở nó lên bằng wireshark và xem thử: Thử tìm theo từ khóa thì ta ra được 2 kênh khả nghi chứa flag theo protocol FTP-DATA. Export file ra thì ta được 1 file main theo định dạng ELF cùng 1 tệp zip cần mật khẩu mà trong đó chứa flag.txt có thể lấy flag.\nFile main được định dạng ELF nên ta mở IDA để đọc code của nó Ở đây file main khởi tạo mật khẩu và nó có thể được dùng để giải nén file zip. Đọc rõ hơn:\nLấy thời gian hiện tại và làm tròn theo phút là được s Lấy 5 ký tự đầu tiên của locale (dest) Ghép username (v3) Kết hợp tất cả thành mật khẩu (v6) Đầu tiên, khi ta xem lại thì gói main nằm ở No.168 và khi tra lại thì ta lấy được thời gian v1 rồi sau đó tính theo công thức để lấy s. 1 2 3 v1 = 1743126530 s = v1 - v1 % 60 # 1743126480 Thứ hai về locate thì ta lấy mặc định là en_US.UTF-8 nhưng chỉ lấy 5 kí tự đầu cho dest là: en_US\nCuối cùng, username ta sẽ có được bằng cách tìm kiếm những request được gửi lên thông qua gói tin mà ta có thể xem được và đây là kết quả: 1 2 3 4 5 6 7 # solution.py v1 = 1743126530 s = v1 - v1 % 60 locale_str = \u0026#34;en_US\u0026#34; username = \u0026#34;hacker\u0026#34; password = f\u0026#34;{s}{locale_str}{username}\u0026#34; print(password) #1743126480en_UShacker Giải nén file zip và lấy flag thôi:\nFlag: dice{5k1d_y0ur_w@y_t0_v1ct0ry_t0d4y!!!} Crypto vorpal-sword 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 # server.py #!/usr/local/bin/python import secrets from Crypto.PublicKey import RSA DEATH_CAUSES = [ \u0026#34;a fever\u0026#34;, \u0026#34;dysentery\u0026#34;, \u0026#34;measles\u0026#34;, \u0026#34;cholera\u0026#34;, \u0026#34;typhoid\u0026#34;, \u0026#34;exhaustion\u0026#34;, \u0026#34;a snakebite\u0026#34;, \u0026#34;a broken leg\u0026#34;, \u0026#34;a broken arm\u0026#34;, \u0026#34;drowning\u0026#34;, ] def run_ot(key, msg0, msg1): \u0026#34;\u0026#34;\u0026#34; https://en.wikipedia.org/wiki/Oblivious_transfer#1–2_oblivious_transfer \u0026#34;\u0026#34;\u0026#34; x0 = secrets.randbelow(key.n) x1 = secrets.randbelow(key.n) print(f\u0026#34;n: {key.n}\u0026#34;) print(f\u0026#34;e: {key.e}\u0026#34;) print(f\u0026#34;x0: {x0}\u0026#34;) print(f\u0026#34;x1: {x1}\u0026#34;) v = int(input(\u0026#34;v: \u0026#34;)) assert 0 \u0026lt;= v \u0026lt; key.n, \u0026#34;invalid value\u0026#34; k0 = pow(v - x0, key.d, key.n) k1 = pow(v - x1, key.d, key.n) m0 = int.from_bytes(msg0.encode(), \u0026#34;big\u0026#34;) m1 = int.from_bytes(msg1.encode(), \u0026#34;big\u0026#34;) c0 = (m0 + k0) % key.n c1 = (m1 + k1) % key.n print(f\u0026#34;c0: {c0}\u0026#34;) print(f\u0026#34;c1: {c1}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: with open(\u0026#34;flag.txt\u0026#34;) as f: flag = f.read().strip() print(\u0026#34;=== CHOOSE YOUR OWN ADVENTURE: Vorpal Sword Edition ===\u0026#34;) print(\u0026#34;you enter a cave.\u0026#34;) for _ in range(64): print(\u0026#34;the tunnel forks ahead. do you take the left or right path?\u0026#34;) key = RSA.generate(1024) msgs = [None, None] page = secrets.randbits(32) live = f\u0026#34;you continue walking. turn to page {page}.\u0026#34; die = f\u0026#34;you die of {secrets.choice(DEATH_CAUSES)}.\u0026#34; msgs = (live, die) if secrets.randbits(1) else (die, live) run_ot(key, *msgs) page_guess = int(input(\u0026#34;turn to page: \u0026#34;)) if page_guess != page: exit() print(f\u0026#34;you find a chest containing {flag}\u0026#34;) Theo thử thách, bài này nói về 1-2 oblivious transfer nên mình cũng lên mạng tìm hiểu và đây là các bước mà giao thức này thực hiện:\nAlice có tin nhắn $m_0, m_1$ và 1 cặp khóa RSA $(e, d, N)$. Bob biết được khóa công khai $(e, N)$ của Alice và muốn tin nhắn $m_c$ , với $c \\in {0, 1}$. Alice tạo ngẫu nhiên 2 số $x_0, x_1$ và gửi cho Bob. Bob tạo ngẫu nhiên 1 số $k$ và gửi $v = b+k^e \\mod N$ cho Alice. Alice tính $k_0 = (v-x_0)^d\\mod N$ và $k_1 = (v-x_1)^d\\mod N$ rồi gửi $m_0\u0026rsquo;=m_0+k_0\\mod N$ và $m_1\u0026rsquo;=m_1+k_1\\mod N$ cho Bob. Bob tính và lấy được $m_c=m_c\u0026rsquo;-k\\mod N$ và không lấy được thông tin gì từ $m_{1-c}$ Đọc file server thì ta thấy là hàm run_ot đúng là đang thực hiện giống như 4 bước đầu trong giao thức trên. Và khi ta truy ngược lại thì ta cần biết được page mà được giấu trong tin nhắn live\n1 2 3 4 5 6 7 live = f\u0026#34;you continue walking. turn to page {page}.\u0026#34; die = f\u0026#34;you die of {secrets.choice(DEATH_CAUSES)}.\u0026#34; msgs = (live, die) if secrets.randbits(1) else (die, live) run_ot(key, *msgs) page_guess = int(input(\u0026#34;turn to page: \u0026#34;)) if page_guess != page: exit() Tuy nhiên vì msgs được random giữa (live,die) và (die, live), cùng với việc ta phải nhập đúng page trong 64 lần liên tiếp thì rõ ràng việc làm như Bob là lấy được 1 trong 2 tin nhắn không khả thi(vì xác suất trúng được hết chỉ là $\\dfrac{1}{2^{64}}$) Hơn nữa, ta đã biết được list của các DEATH_CAUSES nên ta cũng có thể tính được hết tất cả các die của chall, tức là ta có thể phân biệt được đâu là live và đâu là die.\nNhận thấy, ta đã biết $c_0, c_1$, 1 trong hai giá trị $m_0, m_1$ thì việc tìm ra được giá trị còn lại phải dựa vào 1 biểu thức tuyến tính giữa 4 biến này xảy ra. Nói rõ hơn: $$ c_0\\equiv m_0+k_0\\mod n $$$$ c_1\\equiv m_1+k_1\\mod n $$$$ \\Leftrightarrow a c_0 -bc_1\\equiv am_0-bm_1 +(ak_0 -bk_1)\\mod n \\ \\ \\ \\ \\ (*) $$Có nghĩa là ta phải tìm v làm sao mà $ak_0-bk_1 \\equiv 0 \\mod n$, với a,b bất kỳ\nĐiều này tương đương với: $(v-x_0)^d\\equiv k(v-x_1)^d \\mod n$ $$ \\Leftrightarrow (v-x_0)^{de}\\equiv k^e(v-x_1)^{de}\\mod n $$Chọn v có điều kiện $\\gcd(v-x_0, n) = 1$ và sử dụng định lý Euler cùng $de\\equiv 1\\mod \\phi(n)$ $$ \\Leftrightarrow v-x_0\\equiv k^e(v-x_1)\\mod n $$$$ \\Leftrightarrow (k^e - 1)(v-x_1)\\equiv x_1-x_0\\mod n $$Thử $k=1,-1$ đều không thỏa nên ta thử $k = 2$\nLúc này, $k^e-1=2^{65537}-1$ là 1 số Mersenne nên các ước nguyên tố của nó có tính chất: Nếu q là một số nguyên tố của 1 số Mersenne: $q\\equiv 1\\mod 65537, q\\equiv \\pm1\\mod 8$\nMặt khác, $n$ là một số nguyên tố 1024 bit nằm trong khoảng $2^{1023}$ đến $2^{1024}-1$ và là rất lớn so với ước nguyên tố điển hình của $2^{65537}-1$.\nHơn nữa, theo Định lý số nguyên tố thì có thể có khoảng $\\dfrac{2^{1023}}{ln(2^{1023})} \\approx \\dfrac{2^{1023}}{709}$ số nguyên tố 1024 bit. Do đó với 1 số nguyên tố 1024 bit ngẫu nhiên, gần như chắc chắn là số đó không có khả năng là ước của $2^{65537}-1$\nVì vậy, $\\gcd(k^e-1,n)=1$ tương đương với tồn tại nghịch đảo modulo n của $2^{65537}-1$ $$ \\Leftrightarrow v-x_1\\equiv (k^e - 1)^{-1}(x_1-x_0)\\mod n $$$$ \\Leftrightarrow v\\equiv (k^e - 1)^{-1}(x_1-x_0) + x_1\\mod n $$ 1 2 3 4 5 e = 65537 k = 2**e - 1 def sol_v(n, k, x0, x1): d = inverse(k, n) return (x1 + d*(x1-x0)) % n Bây giờ trở lại với $(*)$ thì ta được biểu thức tuyến tính sau: $$ \\Leftrightarrow c_0 -2c_1\\equiv m_0-2m_1\\mod n \\ \\ \\ \\ \\ (**) $$Lúc này, ta chia 2 trường hợp rõ ràng:\nnếu page nằm trong live của $m_0$: $$ (**)\\Leftrightarrow m_0\\equiv c_0 -2c_1+2m_1\\mod n $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 def case_m0(n, c0, c1, lst): page = -1 for i in lst: k = (c0 - 2*c1 + 2*i) % n try: res = long_to_bytes(k) except ValueError: continue if res.startswith(b\u0026#34;you continue walking. turn to page \u0026#34;): page = res[35:-1] if page.isdigit(): break return page nếu page nằm trong live của $m_1$: $$ (**)\\Leftrightarrow m_1\\equiv (m_0-c_0+2c_1)\\times 2^{-1}\\mod n $$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 def case_m1(n, c0, c1, lst): page = -1 inv = inverse(2, n) for j in lst: k = (j - c0 + 2*c1)*inv % n try: res = long_to_bytes(k) except ValueError: continue if res.startswith(b\u0026#34;you continue walking. turn to page \u0026#34;): page = res[35:-1] if page.isdigit(): break return page Đến đây rồi thì, ta brute-force hết cái list của die thì ta sẽ biết được trường hợp nào là thỏa và tìm được page. Remote tới server và nhận flag thôi :333\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 # solution.py from pwn import * from Crypto.Util.number import * import sys sys.set_int_max_str_digits(0) DEATH_CAUSES = [ \u0026#39;a fever\u0026#39;, \u0026#39;dysentery\u0026#39;, \u0026#39;measles\u0026#39;, \u0026#39;cholera\u0026#39;, \u0026#39;typhoid\u0026#39;, \u0026#39;exhaustion\u0026#39;, \u0026#39;a snakebite\u0026#39;, \u0026#39;a broken leg\u0026#39;, \u0026#39;a broken arm\u0026#39;, \u0026#39;drowning\u0026#39;, ] lst = [] for i in DEATH_CAUSES: die = f\u0026#39;you die of {i}.\u0026#39; s = int.from_bytes(die.encode(), \u0026#39;big\u0026#39;) lst.append(s) def rev_data(): return int(io.recvline().strip().decode()) def take_data1(): io.recvuntil(\u0026#34;n: \u0026#34;) n = rev_data() io.recvuntil(\u0026#34;x0: \u0026#34;) x0 = rev_data() io.recvuntil(\u0026#34;x1: \u0026#34;) x1 = rev_data() return n, x0, x1 e = 65537 k = 2**e - 1 def sol_v(n, k, x0, x1): d = inverse(k, n) return (x1 + d*(x1-x0)) % n def take_data2(): io.recvuntil(\u0026#34;c0: \u0026#34;) c0 = rev_data() io.recvuntil(\u0026#34;c1: \u0026#34;) c1 = rev_data() return c0, c1 def case_m0(n, c0, c1, lst): page = -1 for i in lst: k = (c0 - 2*c1 + 2*i) % n try: res = long_to_bytes(k) except ValueError: continue if res.startswith(b\u0026#34;you continue walking. turn to page \u0026#34;): page = res[35:-1] if page.isdigit(): break return page def case_m1(n, c0, c1, lst): page = -1 inv = inverse(2, n) for j in lst: k = (j - c0 + 2*c1)*inv % n try: res = long_to_bytes(k) except ValueError: continue if res.startswith(b\u0026#34;you continue walking. turn to page \u0026#34;): page = res[35:-1] if page.isdigit(): break return page io = remote(\u0026#34;dicec.tf\u0026#34;, 31001) for _ in range(64): n, x0, x1 = take_data1() v = sol_v(n, k, x0, x1) io.recvuntil(\u0026#34;v: \u0026#34;) io.sendline(str(v)) c0, c1 = take_data2() page = case_m0(n, c0, c1, lst) if page == -1: page = case_m1(n, c0, c1, lst) io.recvuntil(\u0026#34;turn to page: \u0026#34;) io.sendline(page) data = io.recvall() print(data) io.close() Flag: dice{gl3am1ng_g0ld_doubl00n} ","date":"2025-03-26T09:31:43+07:00","image":"https://r1muru2006.github.io/p/dicectf-2025/dicectf_hu_78ebaeac5539b671.png","permalink":"https://r1muru2006.github.io/p/dicectf-2025/","title":"DiceCTF 2025"},{"content":" Theo cá nhân mình thấy các challenge về crypto của giải phân hóa rõ ràng các mức độ khác nhau\nGeneral FANTASY CTF Bài này mình nghĩ là chọn hướng nào cũng ra được vì đến cuối cùng sẽ đẩy ra flag :))\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 FANTASY CTF SIMULATION The simulation begins in the private room of Eibhilin, a bright, young student. The room is dimly lit, with the glow of her multiple monitors casting an electric blue hue on the walls. Around the room are posters of vintage movies from the MCU — ancient guardians from another age staring down like digital sentinels. --- (Press Enter to continue...) --- Eibhilin stretches back in her chair, adjusting the holo-display of her keyboard. A soft hum of a nearby server fills the air as her AI companion, `Nyx`, comes to life. --- (Press Enter to continue...) --- \u0026#34;Good evening, Ei,\u0026#34; Nyx chirps, \u0026#34;The 3025 edition of picoCTF registration is open. You asked me to remind so you could try out the competition for the first time. Do you wish to proceed?\u0026#34; --- (Press Enter to continue...) --- Outside, the city of Nexalus glimmers under the stars, but Eibhilin\u0026#39;s focus remains entirely on the screen in front of her. --- (Press Enter to continue...) --- \u0026#34;Yes, Nyx. Let\u0026#39;s do it!\u0026#34; --- (Press Enter to continue...) --- Nyx brings up the registration page. Options: A) *Register multiple accounts* B) *Share an account with a friend* C) *Register a single, private account* [a/b/c] \u0026gt; A Nyx chimes in, \u0026#34;Eibhilin, don\u0026#39;t do that! That\u0026#39;s been grounds for disqualification for the past 1,000 years!\u0026#34; --- (Press Enter to continue...) --- \u0026#34;Oh, thanks Nyx, that was close!\u0026#34; --- (Press Enter to continue...) --- \u0026#34;Ok,\u0026#34; Nyx says, \u0026#34;Registering you for the competition... There\u0026#39;s an introductory audio message, piping to your speakers.\u0026#34; --- (Press Enter to continue...) --- \u0026#34;Welcome hacker! You\u0026#39;re about to embark on a journey that will teach you many esoteric and valuable skills. Our mission is to guide you in the right path, that you may use these skills to protect and defend and never for selfish gain or deceit. We hope you enjoy the challenges that our authors have devised this year. Always remember: \u0026#39;With great power, comes great responsibility!\u0026#39;\u0026#34; --- (Press Enter to continue...) --- Nyx continues, \u0026#34;I\u0026#39;ve gleaned from the Ether that in CTF competitions, it\u0026#39;s always good to start with the \u0026#39;sanity\u0026#39; challenge. It should be the challenge worth the least amount of points. I\u0026#39;ll pull it up. You\u0026#39;re looking for something called the flag. You should know it when you see it.\u0026#34; --- (Press Enter to continue...) --- \u0026#34;Oh interesting,\u0026#34; Eibhilin says, \u0026#34;It seems like the sanity challenge is an old school interactive fiction game.\u0026#34; --- (Press Enter to continue...) --- Options: A) *Play the game* B) *Search the Ether for the flag* [a/b] \u0026gt; A \u0026#34;Good choice, Ei,\u0026#34; Nyx says, \u0026#34;You never want to share flags or artifact downloads.\u0026#34; --- (Press Enter to continue...) --- Playing the Game Playing the Game: 0%| [time left: ?] Playing the Game: 100%|██████████████████████████████████████ [time left: 00:00] Playing the Game completed successfully! --- (Press Enter to continue...) --- \u0026#34;That was fun!\u0026#34; Eibhilin exclaims, \u0026#34;I found the flag!\u0026#34; --- (Press Enter to continue...) --- Nyx says, \u0026#34;Great job, Ei! I\u0026#39;ve read that a lot of players create writeups of interesting challenges they solve during the competition. Just be sure to wait to publish them until after the winners have been announced. We can work on that together if you\u0026#39;d like.\u0026#34; --- (Press Enter to continue...) --- \u0026#34;Thanks, Nyx! Here\u0026#39;s the flag I found: picoCTF{m1113n1um_3d1710n_76b680a5}\u0026#34; --- (Press Enter to continue...) --- \u0026#34;Great, you just got 10 points!\u0026#34; Nyx exclaims. --- (Press Enter to continue...) --- Eibhilin smiles, \u0026#34;I\u0026#39;m off to a good start!\u0026#34; --- (Press Enter to continue...) --- Nyx says, \u0026#34;Let\u0026#39;s keep going!\u0026#34; --- (Press Enter to continue...) --- END OF FANTASY CTF SIMULATION Thank you for playing! To reemphasize some rules for this year: 1. Register only one account. 2. Do not share accounts, flags or artifact downloads. 3. Wait to publish writeups publicly until after the organizers announce the winners. 4. picoCTF{m1113n1um_3d1710n_76b680a5} is a real flag! Submit it for some points in picoCTF 2025! --- (Press Enter to continue...) --- FLag: picoCTF{m1113n1um_3d1710n_76b680a5} Crypto hashcrack Ở bài này mình dựa vào số bytes của hash và các tools online để tìm ra password, như là: MD5, SHA1, SHA256\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Welcome!! Looking For the Secret? We have identified a hash: 482c811da5d5b4bc6d497ffa98491e38 //md5 Enter the password for identified hash: password123 Correct! You\u0026#39;ve cracked the MD5 hash with no secret found! Flag is yet to be revealed!! Crack this hash: b7a875fc1ea228b9061041b7cec4bd3c52ab3ce3 //sha1 Enter the password for the identified hash: letmein Correct! You\u0026#39;ve cracked the SHA-1 hash with no secret found! Almost there!! Crack this hash: 916e8c4f79b25028c9e467f1eb8eee6d6bbdff965f9928310ad30a8d88697745 //sha256 Enter the password for the identified hash: qwerty098 Correct! You\u0026#39;ve cracked the SHA-256 hash with a secret found. The flag is: picoCTF{UseStr0nG_h@shEs_\u0026amp;PaSswDs!_eff9dbe0} Flag: picoCTF{UseStr0nG_h@shEs_\u0026amp;PaSswDs!_eff9dbe0} EVEN RSA CAN BE BROKEN??? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # source.py from sys import exit from Crypto.Util.number import bytes_to_long, inverse from setup import get_primes e = 65537 def gen_key(k): \u0026#34;\u0026#34;\u0026#34; Generates RSA key with k bits \u0026#34;\u0026#34;\u0026#34; p,q = get_primes(k//2) N = p*q d = inverse(e, (p-1)*(q-1)) return ((N,e), d) def encrypt(pubkey, m): N,e = pubkey return pow(bytes_to_long(m.encode(\u0026#39;utf-8\u0026#39;)), e, N) def main(flag): pubkey, _privkey = gen_key(1024) encrypted = encrypt(pubkey, flag) return (pubkey[0], encrypted) if __name__ == \u0026#34;__main__\u0026#34;: flag = open(\u0026#39;flag.txt\u0026#39;, \u0026#39;r\u0026#39;).read() flag = flag.strip() N, cypher = main(flag) print(\u0026#34;N:\u0026#34;, N) print(\u0026#34;e:\u0026#34;, e) print(\u0026#34;cyphertext:\u0026#34;, cypher) exit() Mở kênh kết nối thì ta nhận được N, e, cipher\n1 2 3 N = 14971332928931600258070222525511394212054658902871612141186429243227295047197174853004285765481866838784351475089613251384629214373054886098787783629288854 e = 65537 cipher = 9685487452310081650666414304396053822632884035194331224959800780976444606689190315693089108703603608391361578584998640257817456167504699460118188426557775 Đoạn này mình thấy sai sai vì N chẵn làm mình nghĩ sao bài này nó dễ vậy được và đúng là nó dễ thật @@\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from Crypto.Util.number import long_to_bytes # Lấy từ (nc verbal-sleep.picoctf.net 51510) N = 14971332928931600258070222525511394212054658902871612141186429243227295047197174853004285765481866838784351475089613251384629214373054886098787783629288854 e = 65537 cipher = 9685487452310081650666414304396053822632884035194331224959800780976444606689190315693089108703603608391361578584998640257817456167504699460118188426557775 p = 2 q = N // p phi = (p - 1) * (q - 1) d = pow(e, -1, phi) flag = long_to_bytes(pow(cipher, d, N)) print(flag.decode(\u0026#34;utf-8\u0026#34;)) Flag: picoCTF{tw0_1$_pr!m3625a858b} Guess My Cheese (Part 1) 1 2 3 4 5 6 7 8 9 10 11 ******************************************* *** Part 1 *** *** The Mystery of the CLONED RAT *** ******************************************* The super evil Dr. Lacktoes Inn Tolerant told me he kidnapped my best friend, Squeexy, and replaced him with an evil clone! You look JUST LIKE SQUEEXY, but I\u0026#39;m not sure if you\u0026#39;re him or THE CLONE. I\u0026#39;ve devised a plan to find out if YOU\u0026#39;RE the REAL SQUEEXY! If you\u0026#39;re Squeexy, I\u0026#39;ll give you the key to the cloning room so you can maul the imposter... Here\u0026#39;s my secret cheese -- if you\u0026#39;re Squeexy, you\u0026#39;ll be able to guess it: LRGGHOZMFOVPB Hint: The cheeses are top secret and limited edition, so they might look different from cheeses you\u0026#39;re used to! Commands: (g)uess my cheese or (e)ncrypt a cheese What would you like to do? Hint: Remember that cipher we devised together Squeexy? The one that incorporates your affinity for linear equations Thử thách nhắc tới phương trình tuyến tính và affinity nên mình đã google xem thử nó nói về cái gì và đây là kết quả: Affine transformation\nBản đồ affine $f$ tác dụng lên $x$ được biểu diển dưới dạng: $y \\equiv f(x)=ax+b$ (mod m).\nKhi áp dụng vào mã hóa thì $y$ là bản mã (Ciphertext), còn $x$ là bản rõ (Plaintext). Nghĩa là:\nKhi mã hóa: $C\\equiv aP+b$ (mod m) Khi giải mã: $P=a^{-1}(C-b)$ (mod m) Ở đây, ta thấy nó được mã hóa theo từng chữ cái trên bảng Latinh nên $m$ sẽ là số lượng chữ cái và hơn nữa để giải mã được thì phải tồn tại nghịch đảo modulo $m$ của $a$.\nVà để làm được điều đó thì $m, a$ phải đôi một nguyên tố cùng nhau. Xem thêm ở đây\n1 possible_a = [a for a in range(1, M) if gcd(a, M) == 1] Vì chỉ xét tới chữ cái in hoa nên ta sẽ lấy $M=26$. Ở đây, thử thách cho mình 2 quyền đoán cheese đưa ra và mã hóa 1 cheese nào đó. Để mà đoán được cheese thì ta cần hệ số $a, b$ và từ đó giải mã ra bản rõ. Do đó, mình sẽ mã hóa 1 cheese nào đó trước rồi đối chiếu và lấy $a, b$ và giải mã để lấy flag.\n1 2 3 4 5 6 What would you like to do? e What cheese would you like to encrypt? Cottage cheese Here\u0026#39;s your encrypted cheese: JFMMBZRMJQRRVR Not sure why you want it though...*squeak* - oh well! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 # solution.py from string import ascii_uppercase from Crypto.Util.number import inverse, GCD # Bảng chữ cái ALPHABET = ascii_uppercase M = len(ALPHABET) # M = 26 possible_a = [a for a in range(1, M) if GCD(a, M) == 1] def affine_decrypt(ciphertext, a, b): a_inv = inverse(a, M) plaintext = \u0026#34;\u0026#34; for char in ciphertext: C = ALPHABET.index(char) P = (a_inv * (C - b)) % M plaintext += ALPHABET[P] return plaintext # Mẫu ban đầu với Cottage Cheese cipher_pattern = \u0026#34;JFMMBZRMJQRRVR\u0026#34; cipher = \u0026#34;LRGGHOZMFOVPB\u0026#34; found = False for a in possible_a: for b in range(M): decrypted = affine_decrypt(cipher_pattern, a, b) if \u0026#39;COTTAGE\u0026#39; in decrypted: found = True break if found: break cheese = affine_decrypt(cipher, a, b) print(cheese) # WELLINGTONSKA Nhập cheese vào guess và ta lấy được flag\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 I don\u0026#39;t wanna talk to you too much if you\u0026#39;re some suspicious character and not my BFF Squeexy! You have 2 more chances to prove yourself to me! Commands: (g)uess my cheese or (e)ncrypt a cheese What would you like to do? g _ _ (q\\_/p) /. .\\.-.....-. ___, =\\_t_/= / `\\ ( )\\ ))__ __\\ |___) (/-(/` `nn---\u0026#39; SQUEAK SQUEAK SQUEAK _ _ (q\\_/p) /. .\\ ,__ =\\_t_/= ) / \\ ( (( )) \\ /\\) (/\\ `-\\ Y / nn^nn Is that you, Squeexy? Are you ready to GUESS...MY...CHEEEEEEESE? Remember, this is my encrypted cheese: LRGGHOZMFOVPB So...what\u0026#39;s my cheese? WELLINGTONSKA _ _ (q\\_/p) /. .\\ __ ,__ =\\_t_/= .\u0026#39;o O\u0026#39;-. ) / \\ / O o_.-`| ( (( )) /O_.-\u0026#39; O | \\ /\\) (/\\ | o o o| `-\\ Y / |o o O.-` nn^nn | O _.-\u0026#39; \u0026#39;--` munch... _ _ (q\\_/p) /. .\\ __ ,__ =\\_t_/= .\u0026#39;o O\u0026#39;-. ) / \\ / O o_.-`| ( (( )) ).-\u0026#39; O | \\ /\\) (/\\ ) o o| `-\\ Y / |o o O.-` nn^nn | O _.-\u0026#39; \u0026#39;--` munch... _ _ (q\\_/p) /. .\\ __ ,__ =\\_t_/= .\u0026#39;o O\u0026#39;-. ) / \\ / O o_.-`| ( (( )) )\u0026#39; O | \\ /\\) (/\\ ) o| `-\\ Y / ) O.-` nn^nn ) _.-\u0026#39; \u0026#39;--` MUNCH............. YUM! MMMMmmmmMMMMmmmMMM!!! Yes...yesssss! That\u0026#39;s my cheese! Here\u0026#39;s the password to the cloning room: picoCTF{ChEeSy033d0004} Flag: picoCTF{ChEeSy033d0004} ChaCha Slide 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # challenge.py import secrets import hashlib from Crypto.Cipher import ChaCha20_Poly1305 flag = open(\u0026#34;flag.txt\u0026#34;).read().strip() def shasum(x): return hashlib.sha256(x).digest() key = shasum(shasum(secrets.token_bytes(32) + flag.encode())) # Generate a random nonce to be extra safe nonce = secrets.token_bytes(12) messages = [ \u0026#34;Did you know that ChaCha20-Poly1305 is an authenticated encryption algorithm?\u0026#34;, \u0026#34;That means it protects both the confidentiality and integrity of data!\u0026#34; ] goal = \u0026#34;But it\u0026#39;s only secure if used correctly!\u0026#34; def encrypt(message): cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce) ciphertext, tag = cipher.encrypt_and_digest(message) return ciphertext + tag + nonce def decrypt(message_enc): ciphertext = message_enc[:-28] tag = message_enc[-28:-12] nonce = message_enc[-12:] cipher = ChaCha20_Poly1305.new(key=key, nonce=nonce) plaintext = cipher.decrypt_and_verify(ciphertext, tag) return plaintext for message in messages: print(\u0026#34;Plaintext: \u0026#34; + repr(message)) message = message.encode() print(\u0026#34;Plaintext (hex): \u0026#34; + message.hex()) ciphertext = encrypt(message) print(\u0026#34;Ciphertext (hex): \u0026#34; + ciphertext.hex()) print() print() user = bytes.fromhex(input(\u0026#34;What is your message? \u0026#34;)) user_message = decrypt(user) print(\u0026#34;User message (decrypted): \u0026#34; + repr(user_message)) if goal in repr(user_message): print(flag) Kết nối với kênh, ta được đoạn tin sau:\n1 2 3 4 5 6 7 8 9 10 11 Plaintext: \u0026#39;Did you know that ChaCha20-Poly1305 is an authenticated encryption algorithm?\u0026#39; Plaintext (hex): 44696420796f75206b6e6f7720746861742043686143686132302d506f6c793133303520697320616e2061757468656e7469636174656420656e6372797074696f6e20616c676f726974686d3f Ciphertext (hex): 7cb5f2e754caea3d3d98048ee7d747c1b677b5ac33a000d74c86b68f7f25a955db62e0a8fd17b0235cfc0541a7f8edf105a5d1ab6a6489cfacb7e4061f5b1c8f4f04e9624220e4cb450bae1e13da93a564ed04959dbde00eb0e72b772fb4a5a47457ad46b48a03432d Plaintext: \u0026#39;That means it protects both the confidentiality and integrity of data!\u0026#39; Plaintext (hex): 54686174206d65616e732069742070726f746563747320626f74682074686520636f6e666964656e7469616c69747920616e6420696e74656772697479206f66206461746121 Ciphertext (hex): 6cb4f7b30dc8fa7c38854b90b3835fd2ad2393a7269048d411c2f3ff6421b5448b3dbbeefd00f52c46b50558bae4f1bf10a2d6ea776f998aaeabee001f0b0780000ea8774f66f3102a46013366d9ab4b0cf5b4320020b4a5a47457ad46b48a03432d What is your message? Sơ lược lại thì thử thách nói về hệ mã dòng có xác thực ChaCha20 - Poly1305. Rõ hơn thì đề cho ta hai đoạn tin nhắn và bản mã của chúng, yêu cầu ta gửi tới bản mã của goal được cho để nhận về flag của chall.\nĐể gửi được đúng bản mã của goal, ta phải tìm được 3 phần gồm: ciphertext, tag, nonce. Đơn giản với nonce vì nó đã trùng với cái của 2 ciphertext mẫu có sẵn. Còn ciphertext thì liên quan tới phần mã hóa của Chacha20, tag liên quan tới phần xác thực của Poly1305\nVì vậy, ta chia ChaCha20 - Poly1305 thành hai phần để phân tích và tấn công:\nVề Chacha20: Phương thức này sử dụng mã hóa XOR với keystream là XOR key.\nNghĩa là: Ciphertext = Plaintext $\\oplus$ Keystream\n$\\Leftrightarrow$ Ciphertext $\\oplus$ Plaintext = Plaintext $\\oplus$ Keystream $\\oplus$ Plaintext = Keystream\nVà khi mà ta đã biết cái plaintext ở goal rồi thì việc giải mã sẽ đơn giản bằng known-plaintext attack như sau: goal_ct = goal $\\oplus$ Keystream = goal $\\oplus$ Ciphertext $\\oplus$ Plaintext\n1 2 3 4 5 6 ciphertext = bytes( [ c1 ^ p1 ^ p2 for c1, p1, p2 in zip(ciphertext1, plaintext1, goal) ] ) # vì độ dài goal nhỏ hơn ciphertext1 nên keystream sẽ chạy hết được goal Poly1305: Phần này mới thực sự là phức tạp của thử thách, với mục đích chính là tìm cái tag để server check xem có đúng không. Sau khi google thì ta biết được rằng Poly1305 được dùng như mã xác thực một lần với:\n$$ tag \\equiv Poly1305_r(m)+s \\mod 2^{128} $$Đề cho ta 2 tag của 2 tin nhắn phân biệt mà ta đã biết và được dùng cùng 1 Poly1305 key bí mật (r,s). Bây giờ, chúng ta phải tìm lại key này để giải mã được cấu trúc tạo tag.\nVà ở đây cũng có để cách attack nếu sử dụng 2 lần để mã hóa tin nhắn bằng 1 key.\n$$ tag_1 = (Poly1305_r(m_1) + s )\\mod 2^{128} \\ (1) $$$$ tag_2 = (Poly1305_r(mg_2) + s )\\mod 2^{128} \\ (2) $$Từ (1) và (2), ta có:\n$$ tag_1 - tag_2 \\equiv Poly1305_r(m_1)- Poly1305_r(m_2) \\mod 2^{128} $$Mình xem ở đây để phân tích cái Poly1305 ra: $$ tag_1 - tag_2 \\equiv (c_1^1r^q+c_1^2r^{q-1}+...+c_1^qr^1\\mod 2^{130} -5) $$$$ -(c_2^1r^q+c_2^2r^{q-1}+...+c_2^qr^1\\mod 2^{130} -5) \\mod 2^{128} $$$$ \\Leftrightarrow tag_1 - tag_2 + 2^{128}(i-j) \\equiv (((c_1^1-c_2^1)r^q+(c_1^2-c_2^2)r^{q-1}+...+(c_1^q-c_2^q)r^1) \\mod 2^{130} -5) $$Vì tag ban đầu mod 1 giá trị bằng $2^{130} - 5$, gần bằng 130 bits rồi mod $2^{128}$ nghĩa là tag mất 2 bits nên $i,j \\in \\overline{0,4} \\Rightarrow (i-j)\\in \\overline{-4,4}$.\nĐặt $k = i-j$ thì với mỗi k, ta sẽ dựng 1 phương trình trên GF($2^{130}-5$), tìm nghiệm của phương trình này và nó là r rồi thế lại vào 1 trong hai phương trình trên là ta ra được s\nKhi đã có được r, s đối với cặp (key, nonce) này rồi thì ta hoàn toàn có thể tạo 1 cái tag xác thực được cho ciphertext của goal và đây cũng là cách mình thực hiện thử thách này.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 # solution.py from pwn import * from Crypto.Util.Padding import pad, unpad import sage.all as sage io = remote(\u0026#34;activist-birds.picoctf.net\u0026#34;, 59584) plaintext1 = ( b\u0026#34;Did you know that ChaCha20-Poly1305 is an authenticated encryption algorithm?\u0026#34; ) def data(): io.recvuntil(\u0026#34;Ciphertext (hex): \u0026#34;) message_enc = io.recvline().decode().split(\u0026#34;\\n\u0026#34;)[0] # lấy từ ciphertext của plaintext từ server message_enc = bytes.fromhex(message_enc) ciphertext = message_enc[:-28] tag = message_enc[-28:-12] nonce = message_enc[-12:] return ciphertext, tag, nonce ciphertext1, tag1, nonce = data() ciphertext2, tag2, nonce = data() goal = b\u0026#34;But it\u0026#39;s only secure if used correctly!\u0026#34; ciphertext = bytes( [ c1 ^ p1 ^ p2 for c1, p1, p2 in zip(ciphertext1, plaintext1, goal) ] ) # vì độ dài goal nhỏ hơn ciphertext1 nên keystream sẽ chạy hết được goal def make_poly(ct): data = b\u0026#34;\u0026#34; mac_data = data + pad(data, 16) mac_data += ct + pad(ct, 16) mac_data += struct.pack(\u0026#34;\u0026lt;Q\u0026#34;, len(data)) mac_data += struct.pack(\u0026#34;\u0026lt;Q\u0026#34;, len(ct)) f = 0 for i in range(0, round(len(mac_data) / 16)): n = mac_data[i * 16 : (i + 1) * 16] + b\u0026#34;\\x01\u0026#34; n += (17 - len(n)) * b\u0026#34;\\x00\u0026#34; f = (f + int.from_bytes(n, \u0026#34;little\u0026#34;)) * x return f tag1_int = int.from_bytes(tag1, \u0026#34;little\u0026#34;) tag2_int = int.from_bytes(tag2, \u0026#34;little\u0026#34;) Pr = sage.PolynomialRing(sage.GF(2**130 - 5), \u0026#34;x\u0026#34;) x = Pr.gen() f1 = make_poly(ciphertext1) f2 = make_poly(ciphertext2) print(f1) print(f2) # 597196402248105951626966011877782631804*x^6 + 454145005287357688070972442197395601334*x^5 + 661861931549384550481074575939827950299*x^4 + 530509202787700791233082061683076211973*x^3 + 340282368435768507855198875253190755407*x^2 + 340282366920938464883773901107403685888*x # 619916185459487913787536860817282020460*x^6 + 431610353687254081499753564988673041325*x^5 + 595420896811833730416722478289825512843*x^4 + 510460122022284652188488210929459569168*x^3 + 340282366920938463463374719923264163328*x^2 + 340282366920938464754646692591436824576*x res = [] for k in range(-4, 5): rhs = tag1_int - tag2_int + 2**128 * k print(rhs, k) f = rhs - (f1 - f2) for r, _ in f.roots(): if int(r).bit_length() \u0026lt;= 124: s = (tag1_int - int(f1(r))) % (2**128) res.append((r, s)) print(res) # [(20320015409774457323517351832911875936, 340179677694136160511250274535902749702)] for r, s in res: f = make_poly(ciphertext) tag = (int(f(r)) + s) % 2**128 print(tag) # 314525754662942930020042292487713459951 tag = int(tag).to_bytes(16, \u0026#34;little\u0026#34;) message = (ciphertext + tag + nonce).hex() print(message) # 7aa9e2e744d1b86e76990595be835cc5a12284a1728a0e960bc5febb302abf169a37b6fcf81db1ef0ee4d59f089de8f06ea49ef8749fecb4a5a47457ad46b48a03432d io.recvuntil(\u0026#34;What is your message? \u0026#34;) io.sendline(message) io.recvline() flag = io.recvline().decode() print(flag) Trong lúc làm bài thì mình nhập trực tiếp tới server nên được như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Plaintext: \u0026#39;Did you know that ChaCha20-Poly1305 is an authenticated encryption algorithm?\u0026#39; Plaintext (hex): 44696420796f75206b6e6f7720746861742043686143686132302d506f6c793133303520697320616e2061757468656e7469636174656420656e6372797074696f6e20616c676f726974686d3f Ciphertext (hex): 7cb5f2e754caea3d3d98048ee7d747c1b677b5ac33a000d74c86b68f7f25a955db62e0a8fd17b0235cfc0541a7f8edf105a5d1ab6a6489cfacb7e4061f5b1c8f4f04e9624220e4cb450bae1e13da93a564ed04959dbde00eb0e72b772fb4a5a47457ad46b48a03432d Plaintext: \u0026#39;That means it protects both the confidentiality and integrity of data!\u0026#39; Plaintext (hex): 54686174206d65616e732069742070726f746563747320626f74682074686520636f6e666964656e7469616c69747920616e6420696e74656772697479206f66206461746121 Ciphertext (hex): 6cb4f7b30dc8fa7c38854b90b3835fd2ad2393a7269048d411c2f3ff6421b5448b3dbbeefd00f52c46b50558bae4f1bf10a2d6ea776f998aaeabee001f0b0780000ea8774f66f3102a46013366d9ab4b0cf5b4320020b4a5a47457ad46b48a03432d What is your message? 7aa9e2e744d1b86e76990595be835cc5a12284a1728a0e960bc5febb302abf169a37b6fcf81db1ef0ee4d59f089de8f06ea49ef8749fecb4a5a47457ad46b48a03432d User message (decrypted): b\u0026#34;But it\u0026#39;s only secure if used correctly!\u0026#34; picoCTF{7urn_17_84ck_n0w_77243c82} Flag: picoCTF{7urn_17_84ck_n0w_77243c82} Guess My Cheese (Part 2) Mình để bài này sau cùng vì thực sự thì nó khá là tricky và xém nữa thì mình có thể làm ra nó sớm hơn trong quá trình giải bài nhưng không được.\nThử thách cho ta một cái cheese_list.txt chứa 599 loại cheese cùng với đó là server được kết nối như Part 1 chỉ khác 1 chỗ là không được mã hóa một loại cheese mà ta cho trước.\nỞ đây thì hint có nhắc tới Salt là 2 ký tự thập lục phân và gợi ý cho ta dùng Rainbow table\nĐầu tiên, mình cũng brute-force băm SHA256 hết các cheese cộng với việc thêm salt vào cuối $\\rightarrow$ không ra. Sau đó, mình nghĩ tới việc băm trước rồi thêm salt sau đó băm tiếp $\\rightarrow$ cũng không ra. Rồi mình nghĩ tới việc thêm salt vào từng ký tự xen giữa của cheese rồi băm và tất nhiên $\\rightarrow$ không ra. Tiếp theo, mình nghĩ là ồ Part 1 đã cho ta chữ cái in hoa rồi thì có thể phải in hoa hết các cheese xong mới thực hiện $\\rightarrow$ không ra.\nLúc đó mình cũng không nghĩ tới việc là phải ngược lại là in thường hết các cheese và nó đúng thật là như vậy\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # solution.py from hashlib import sha256 with open( \u0026#34;cheese_list.txt\u0026#34;, \u0026#34;r\u0026#34;, ) as f: data = f.readlines() cheeses = [line.strip().lower() for line in data] chall = \u0026#34;9b71b2b23fa26641a0096848f97b78718975832f37ab770c60398949cd991a14\u0026#34; rainbow_table = {} for cheese in cheeses: for salt in range(256): x = cheese.encode() + salt.to_bytes(1, byteorder=\u0026#39;big\u0026#39;) new_cheese_hash = sha256(x).hexdigest() rainbow_table[new_cheese_hash] = x if chall in rainbow_table: x = rainbow_table[chall] print(x) # b\u0026#39;pyramide\\xa9\u0026#39; Gửi cheese rồi sau đó là salt vào server thì ta nhận được flag\u0026hellip;\n","date":"2025-03-22T13:52:19+07:00","image":"https://r1muru2006.github.io/p/picoctf-2025/picoCTF_hu_e0caee6ff9335949.png","permalink":"https://r1muru2006.github.io/p/picoctf-2025/","title":"picoCTF 2025"}]