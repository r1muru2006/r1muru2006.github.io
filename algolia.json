[{"objectID":"d4ea1cecd14dfaedad1b711e2abbfb3123141fad","permalink":"/post/streamcipher/","title":"Is stream encryption secure?","content":" Chacha20-Poly1305 Algorithm Chacha20 ChaCha20-Poly1305 architecture consists of two main components, the stream cipher ChaCha20 and the authentication mechanism Poly1305 by the same author D.J. Berstein. The ChaCha20 algorithm uses ChaCha20 block functions to generate the encryption keystream. The input of the ChaCha20 block function is a 4x4 word matrix described as in this figure: More details in figure a are 128 bit constant C (4-word), 256 bit key K (8-word), 32 bit counter parameter Ctr (1 word), 96 bit nonce N (3 words). Then perform 20 loops alternatingly executing the column round transformations according to figure b and the diagonal round transformations according to figure c.\nThese two circular shifts are implemented by a single QUARTERROUND transformation (cross or column shift based on the input index to the QUARTERROUND function) as shown in this: def chacha20_quarter_round(a,b,c,d): a = (a + b) \u0026amp; 0xFFFFFFFF d ^= a; d = ((d \u0026lt;\u0026lt; 16) \u0026amp; 0xFFFFFFFF) | (d \u0026gt;\u0026gt; 16) c = (c + d) \u0026amp; 0xFFFFFFFF b ^= c; b = ((b \u0026lt;\u0026lt; 12) \u0026amp; 0xFFFFFFFF) | (b \u0026gt;\u0026gt; 20) a = (a + b) \u0026amp; 0xFFFFFFFF d ^= a; d = ((d \u0026lt;\u0026lt; 8) \u0026amp; 0xFFFFFFFF) | (d \u0026gt;\u0026gt; 24) c = (c + d) \u0026amp; 0xFFFFFFFF b ^= c; b = ((b \u0026lt;\u0026lt; 7) \u0026amp; 0xFFFFFFFF) | (b \u0026gt;\u0026gt; 25) return a,b,c,d In 20 loops, each loop performs 8 operations QUARTERROUND and the order is: QUARTERROUND from 1 to 4 performs column rotation, while QUARTERROUND from 5 to 8 performs cross rotation. The output of the 20-loop block is 16 words, which are added to the 16 input words modulo $2^{32}$ to generate 16 key words. The 16 key words are XORed with the 16 plaintext words to obtain 16 ciphertext words.\ndef chacha20_block(key32: bytes, counter: int, nonce12: bytes) -\u0026gt; bytes: def u32(b): return struct.unpack(\u0026#34;\u0026lt;I\u0026#34;, b)[0] state = [ 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574, u32(key32[0:4]), u32(key32[4:8]), u32(key32[8:12]), u32(key32[12:16]), u32(key32[16:20]), u32(key32[20:24]), u32(key32[24:28]), u32(key32[28:32]), counter \u0026amp; 0xFFFFFFFF, u32(nonce12[0:4]), u32(nonce12[4:8]), u32(nonce12[8:12]) ] x = state.copy() for _ in range(20): # column rounds x[0],x[4],x[8],x[12] = chacha20_quarter_round(x[0],x[4],x[8],x[12]) x[1],x[5],x[9],x[13] = chacha20_quarter_round(x[1],x[5],x[9],x[13]) x[2],x[6],x[10],x[14] = chacha20_quarter_round(x[2],x[6],x[10],x[14]) x[3],x[7],x[11],x[15] = chacha20_quarter_round(x[3],x[7],x[11],x[15]) # diagonal rounds x[0],x[5],x[10],x[15] = chacha20_quarter_round(x[0],x[5],x[10],x[15]) x[1],x[6],x[11],x[12] = chacha20_quarter_round(x[1],x[6],x[11],x[12]) x[2],x[7],x[8],x[13] = chacha20_quarter_round(x[2],x[7],x[8],x[13]) x[3],x[4],x[9],x[14] = chacha20_quarter_round(x[3],x[4],x[9],x[14]) out = b\u0026#34;\u0026#34;.join(struct.pack(\u0026#34;\u0026lt;I\u0026#34;, (x[i] + state[i]) \u0026amp; 0xFFFFFFFF) for i in range(16)) return out Poly1305 Poly1305 is a message authentication cipher (MAC) to ensure the authenticity and integrity of data. The input key is divided into 2 parts called r and s, each part is 128 bits long. The pair (r,s) must be unique and unguessable for each call.\nThe input message is divided into 16-byte blocks (the last block can be padded with 0 bits), the 16-byte blocks are padded with 1 byte with value 0x01 to 17 bytes, calculations are performed on these blocks with r on the Z() field to create an accumulator. Finally the value s is added to the accumulator and the 128 bits are extracted as the authentication tag. def _clamp_r(r_bytes: bytes) -\u0026gt; int: \u0026#34;\u0026#34;\u0026#34;Convert 16-byte little-endian r_bytes to integer and apply clamp per RFC.\u0026#34;\u0026#34;\u0026#34; if len(r_bytes) != 16: raise ValueError(\u0026#34;r must be 16 bytes\u0026#34;) r = int.from_bytes(r_bytes, \u0026#34;little\u0026#34;) # clamp mask: r \u0026amp;= 0x0ffffffc0ffffffc0ffffffc0fffffff # expressed as integer: clamp_mask = 0x0ffffffc0ffffffc0ffffffc0fffffff return r \u0026amp; clamp_mask def poly1305_mac(msg: bytes, key: bytes) -\u0026gt; bytes: \u0026#34;\u0026#34;\u0026#34; Compute Poly1305 tag for message `msg` using 32-byte one-time key `key` (r||s). Returns 16-byte tag. \u0026#34;\u0026#34;\u0026#34; if len(key) != 32: raise ValueError(\u0026#34;Poly1305 key must be 32 bytes\u0026#34;) r_bytes = key[:16] s_bytes = key[16:32] r = _clamp_r(r_bytes) s = int.from_bytes(s_bytes, \u0026#34;little\u0026#34;) # s added at the end acc = 0 # Process message in 16-byte blocks offset = 0 while offset \u0026lt; len(msg): block = msg[offset:offset + 16] offset += len(block) # n = int.from_bytes(block, \u0026#39;little\u0026#39;) + (1 \u0026lt;\u0026lt; (8*len(block))) # append the 1 byte in little-endian domain: n = int.from_bytes(block + b\u0026#39;\\x01\u0026#39;, \u0026#34;little\u0026#34;) acc = (acc + n) % P130 acc = (acc * r) % P130 # Final tag = (acc + s) mod 2^128 tag_int = (acc + s) % (1 \u0026lt;\u0026lt; 128) tag = tag_int.to_bytes(16, \u0026#34;little\u0026#34;) return tag Security ChaCha20-Poly1305 is generally secure and offers better resistance to timing attacks than AES-GCM. However, like GCM, its security relies strictly on unique nonces. While specific implementations like SSH face vulnerabilities such as the Terrapin attack, this post focuses on a fundamental flaw: exploiting ChaCha20-Poly1305 under nonce reuse.\nReference Hệ mã dòng có xác thực Security of Chacha20-Poly1305 by Wikipedia ","date":"2025-11-25 14:33:54","updated":"2025-11-25 14:33:54"},{"objectID":"3a3bad05b6091bd46e0314aa3a7fa74b737c4561","permalink":"/post/patriotctf2025/","title":"Patriot CTF 2025","content":" Osint Where\u0026amp;rsquo;s Legally Distinct Waldo One We have to find the building place where they take this picture. After using google lens, I got this: It looks exactly the same so I clicked in this article: So we know that it relates to the campus of George Mason University in Fairfax, VA. Therefore, I googled map it and scanned around: In the picture, I noticed an area with a similar patterned tile floor to the challenge in the lower right corner of the photo at the George Mason Statue. When I scanned this street, I saw a corner with the same pattern and the building name Horizon Hall had the same view. Flag: pctf{Horizon_Hall}\nWhere\u0026amp;rsquo;s Legally Distinct Waldo Two I tried many ways with the google lens but this didn\u0026amp;rsquo;t work. Luckily, we know this is a place in the campus above. Therefore, I looked for some identifying features in this challenge. These are a large road with a yellow line in the middle, a street-facing parking space and a pedestrian crossing next to.\nThis …","date":"2025-11-24 21:40:43","updated":"2025-11-24 21:40:43"},{"objectID":"c498b78e02e7579862a36ee8a3806046629bbd4d","permalink":"/post/mctfquals2025/","title":"M*CTF Quals 2025","content":" WELCOME W3lc0m3_ M7_Fr13nd$ This link leads to the main Telegram group for discussing the contest and here I found this post flag.\nHowever, we must remove the * in M*CTF to get the correct flag.\nFlag: MCTF{ok3y_l3ts_g0}\nSBER CRCL35 This is the picture:\nThis is the description of the challenge after translation:\n\u0026amp;#34;Everything... is unreal?\u0026amp;#34; \u0026amp;#34;What is reality? And how do you define it? The entire range of sensations: visual, tactile, olfactory—these are signals from receptors, electrical impulses received by the brain.\u0026amp;#34; \u0026amp;#34;So, it\u0026amp;#39;s all NULL?\u0026amp;#34; \u0026amp;#34;No, it\u0026amp;#39;s all 0. Don\u0026amp;#39;t confuse it and don\u0026amp;#39;t forget the difference, otherwise, during the transformation, you\u0026amp;#39;ll end up in the wrong place.\u0026amp;#34; In the description, I noticed the word \u0026amp;ldquo;difference\u0026amp;rdquo; so I quickly tested this method by python and it worked.\ns0 = [180, 78, 186, 89, 192, 69, 185] s1 = [360, 256, 151, 266, 171, 286, 175] s2 = [520, 425, 326, 215, 104, 212, 337] for arr in (s0, s1, s2): …","date":"2025-11-21 22:19:58","updated":"2025-11-21 22:19:58"},{"objectID":"f974947340c42c641c7ee298d7a0419de7d0226e","permalink":"/post/crackrandommodule/","title":"Crack Random Modules","content":"Khởi động nhẹ nhàng: How To Predict Random Numbers Generated By Computers\n1. Python Hàm random của Python sử dụng thuật toán Mersenne Twister - với 624 số nguyên 32 bit làm trạng thái, sau đó cứ mỗi lần xuất ra một số nguyên 32 bit, nó sẽ thay đổi trạng thái.\nMersenne Twister Ta sẽ phân tích thuật toán tạo số ngẫu nhiên trong khoảng [0,0xffffffff]: Link\n/* Period parameters -- These are all magic. Don\u0026amp;#39;t change. */ #define N 624 #define M 397 #define MATRIX_A 0x9908b0dfU /* constant vector a */ #define UPPER_MASK 0x80000000U /* most significant w-r bits */ #define LOWER_MASK 0x7fffffffU /* least significant r bits */ static uint32_t genrand_uint32(RandomObject *self) { uint32_t y; static const uint32_t mag01[2] = {0x0U, MATRIX_A}; /* mag01[x] = x * MATRIX_A for x=0,1 */ uint32_t *mt; mt = self-\u0026amp;gt;state; if (self-\u0026amp;gt;index \u0026amp;gt;= N) { /* generate N words at one time */ int kk; for (kk=0;kk\u0026amp;lt;N-M;kk++) { y = (mt[kk]ANDUPPER_MASK)|(mt[kk+1]ANDLOWER_MASK); mt[kk] = mt[kk+M] ^ (y …","date":"2025-09-15 20:31:17","updated":"2025-09-15 20:31:17"},{"objectID":"18d2597b60137ed49633aa0ffe165035d132e748","permalink":"/post/imaginaryctf2025/","title":"ImaginaryCTF 2025","content":" Shout out to others member for trying their best and reached the top 15 of the world, ranked 1st University of Technology.\nleaky-rsa chall.py\n#!/usr/local/bin/python3 import json from Crypto.Util.number import getPrime from Crypto.Cipher import AES from Crypto.Util.Padding import pad from secrets import randbelow, token_bytes from hashlib import sha256 with open(\u0026amp;#39;flag.txt\u0026amp;#39;) as f: flag = f.read() p = getPrime(512) q = getPrime(512) n = p * q e = 65537 d = pow(e, -1, (p-1)*(q-1)) key_m = randbelow(n) key_c = pow(key_m, e, n) key = sha256(str(key_m).encode()).digest()[:16] iv = token_bytes(16) ct = AES.new(key, AES.MODE_CBC, IV=iv).encrypt(pad(flag.encode(), 16)) print(json.dumps({\u0026amp;#39;n\u0026amp;#39;: n, \u0026amp;#39;c\u0026amp;#39;: key_c, \u0026amp;#39;iv\u0026amp;#39;: iv.hex(), \u0026amp;#39;ct\u0026amp;#39;: ct.hex()})) def get_bit(n, k): return (n \u0026amp;gt;\u0026amp;gt; k) % 2 for _ in range(1024): idx = randbelow(4) print(json.dumps({\u0026amp;#39;idx\u0026amp;#39;: idx})) try: response = json.loads(input()) c = response[\u0026amp;#39;c\u0026amp;#39;] % n assert c != key_c m = …","date":"2025-09-14 14:17:02","updated":"2025-09-14 14:17:02"},{"objectID":"f2e9becaa3fa64df2e2c7bce57d9510fbbbc047c","permalink":"/post/holactf2025/","title":"HOLACTF 2025","content":" Crypto 1. Cs2RTrash # chall.py from Crypto.Util.number import bytes_to_long, long_to_bytes import random e = 65537 n1 = 106274132069853085771962684070654057294853035674691451636354054913790308627721 n2 = 73202720518342632558813895439681594395095017145510800999002057461861058762579 n3 = 58129476807669651703262865829974447479957080526429581698674448004236654958847 message = b\u0026amp;#39;HOLACTF{...}\u0026amp;#39; m = bytes_to_long(message) c1 = pow(m, e, n1) c2 = pow(m, e, n2) c3 = pow(m, e, n3) print(f\u0026amp;#34;c1: {c1}\u0026amp;#34;) print(f\u0026amp;#34;c2: {c2}\u0026amp;#34;) print(f\u0026amp;#34;c3: {c3}\u0026amp;#34;) // output.txt c1: 40409669713698525444927116587938485167766997176959778633087672968720888190012 c2: 50418608792183022472533104230595523000246213655735834753443442906871618770832 c3: 7151799367443802424297049002310776844321501905398348074481144597918413565153 Đây chỉ là 1 bài RSA đơn giản và mình để ý rằng n1 là số nguyên tố nên bài này có thể được giải như sau:\n# solution.py from Crypto.Util.number import inverse, long_to_bytes e = …","date":"2025-09-09 08:42:30","updated":"2025-09-09 08:42:30"},{"objectID":"e55fb069409807feeb00f2163a00905eaeecc75b","permalink":"/post/nahamconctf2025/","title":"NahamCon CTF 2025","content":" 1. Readtherules Flag: flag{90bc54705794a62015369fd8e86e557b} 2. FreeFlag Thử thách cho ta một file free_flags.txt chứa 1000 flag nên ta nghĩ ngay tới việc sử dụng định dạng mẫu và lọc flag phù hợp.\n# solution.py import re def is_flag(s): pattern = r\u0026amp;#39;^flag\\{[0-9a-f]{32}\\}$\u0026amp;#39; return re.match(pattern, s) with open(\u0026amp;#34;free_flags.txt\u0026amp;#34;, \u0026amp;#39;r\u0026amp;#39;) as f: data = f.readlines() lst = [] for line in data: flag = line.strip().split(\u0026amp;#34; \u0026amp;#34;) for i in flag: lst.append(i) for i in lst: if is_flag(i): print(i) Flag: flag{ae6b6fb0686ec594652afe9eb6088167} 3. Naham Commencement2025 Thử thách cho ta một đường dẫn vào 1 trang đăng nhập, có vẻ như mục đích là ta phải sử dụng đúng tài khoản để truy cập vào và lấy flag. Khi f12, thì ta có source sau:\n// main.js function a(t) { let r = \u0026amp;#39;\u0026amp;#39;; for (let i = 0; i \u0026amp;lt; t.length; i++) { const c = t[i]; if (/[a-zA-Z]/.test(c)) { const d = c.charCodeAt(0); const o = (d \u0026amp;gt;= 97) ? 97 : 65; const x = (d - o + 16) % 26 + o; r += …","date":"2025-06-05 08:19:28","updated":"2025-06-05 08:19:28"},{"objectID":"f4bfa16eb24f77e6e8a14ca830ae410ab7aed2fc","permalink":"/post/wannagamecyberknight2025/","title":"WannaGame Cyber Knight 2025","content":" Trong giải đấu này, mình đã giải được 1 câu trong phần Cryptography và may mắn đứng thứ 8 trên bảng đến cuối (≧▽≦) Sau đây là bài mình giải được trong giải đấu và tiếp đó là những bài mà mình chưa làm được khi còn trong giải.\nChoose! Link: https://www.youtube.com/watch?v=1lqe8eU48HI\n# aes.py #Implementation from https://github.com/boppreh/aes/blob/master/aes.py s_box = ( 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, …","date":"2025-05-16 14:13:38","updated":"2025-05-16 14:13:38"},{"objectID":"1974f6ac6a576e9f83aef16ce167b1601275b280","permalink":"/post/wannagamenmlt/","title":"WannaGame NMLT","content":" Pwn 1. Hello pwner Flag: W1{welcome_to_assembly} Crypto 2. Substitution Tải file, giải nén và mở chall lên:\nKEY = { \u0026amp;#39;A\u0026amp;#39;: \u0026amp;#39;Q\u0026amp;#39;, \u0026amp;#39;B\u0026amp;#39;: \u0026amp;#39;W\u0026amp;#39;, \u0026amp;#39;C\u0026amp;#39;: \u0026amp;#39;E\u0026amp;#39;, \u0026amp;#39;D\u0026amp;#39;: \u0026amp;#39;R\u0026amp;#39;, \u0026amp;#39;E\u0026amp;#39;: \u0026amp;#39;T\u0026amp;#39;, \u0026amp;#39;F\u0026amp;#39;: \u0026amp;#39;Y\u0026amp;#39;, \u0026amp;#39;G\u0026amp;#39;: \u0026amp;#39;U\u0026amp;#39;, \u0026amp;#39;H\u0026amp;#39;: \u0026amp;#39;I\u0026amp;#39;, \u0026amp;#39;I\u0026amp;#39;: \u0026amp;#39;O\u0026amp;#39;, \u0026amp;#39;J\u0026amp;#39;: \u0026amp;#39;P\u0026amp;#39;, \u0026amp;#39;K\u0026amp;#39;: \u0026amp;#39;A\u0026amp;#39;, \u0026amp;#39;L\u0026amp;#39;: \u0026amp;#39;S\u0026amp;#39;, \u0026amp;#39;M\u0026amp;#39;: \u0026amp;#39;D\u0026amp;#39;, \u0026amp;#39;N\u0026amp;#39;: \u0026amp;#39;F\u0026amp;#39;, \u0026amp;#39;O\u0026amp;#39;: \u0026amp;#39;G\u0026amp;#39;, \u0026amp;#39;P\u0026amp;#39;: \u0026amp;#39;H\u0026amp;#39;, \u0026amp;#39;Q\u0026amp;#39;: \u0026amp;#39;J\u0026amp;#39;, \u0026amp;#39;R\u0026amp;#39;: \u0026amp;#39;K\u0026amp;#39;, \u0026amp;#39;S\u0026amp;#39;: \u0026amp;#39;L\u0026amp;#39;, \u0026amp;#39;T\u0026amp;#39;: \u0026amp;#39;Z\u0026amp;#39;, \u0026amp;#39;U\u0026amp;#39;: \u0026amp;#39;X\u0026amp;#39;, \u0026amp;#39;V\u0026amp;#39;: \u0026amp;#39;C\u0026amp;#39;, \u0026amp;#39;W\u0026amp;#39;: \u0026amp;#39;V\u0026amp;#39;, \u0026amp;#39;X\u0026amp;#39;: \u0026amp;#39;B\u0026amp;#39;, \u0026amp;#39;Y\u0026amp;#39;: \u0026amp;#39;N\u0026amp;#39;, \u0026amp;#39;Z\u0026amp;#39;: \u0026amp;#39;M\u0026amp;#39;, \u0026amp;#39;a\u0026amp;#39;: \u0026amp;#39;q\u0026amp;#39;, \u0026amp;#39;b\u0026amp;#39;: \u0026amp;#39;w\u0026amp;#39;, \u0026amp;#39;c\u0026amp;#39;: \u0026amp;#39;e\u0026amp;#39;, \u0026amp;#39;d\u0026amp;#39;: \u0026amp;#39;r\u0026amp;#39;, \u0026amp;#39;e\u0026amp;#39;: \u0026amp;#39;t\u0026amp;#39;, \u0026amp;#39;f\u0026amp;#39;: \u0026amp;#39;y\u0026amp;#39;, \u0026amp;#39;g\u0026amp;#39;: \u0026amp;#39;u\u0026amp;#39;, \u0026amp;#39;h\u0026amp;#39;: \u0026amp;#39;i\u0026amp;#39;, …","date":"2025-04-08 10:07:31","updated":"2025-04-08 10:07:31"},{"objectID":"de7c406106a5abdda2f1ae29aa48e66daba953f0","permalink":"/post/dicectf2025/","title":"DiceCTF 2025","content":" Misc bcu-binding Tải file về thì ta search thử \u0026amp;lsquo;dice{\u0026amp;rsquo; để tìm flag và nó ra thật @@ Có vẻ như nó được giấu trong phần nền trắng để không thể nhìn thấy\u0026amp;hellip;\nFlag: dice{r3ad1ng_th4_d0cs_71ccd} dicecap Đề cho ta 1 file pcap nên ta mở nó lên bằng wireshark và xem thử: Thử tìm theo từ khóa thì ta ra được 2 kênh khả nghi chứa flag theo protocol FTP-DATA. Export file ra thì ta được 1 file main theo định dạng ELF cùng 1 tệp zip cần mật khẩu mà trong đó chứa flag.txt có thể lấy flag.\nFile main được định dạng ELF nên ta mở IDA để đọc code của nó Ở đây file main khởi tạo mật khẩu và nó có thể được dùng để giải nén file zip. Đọc rõ hơn:\nLấy thời gian hiện tại và làm tròn theo phút là được s Lấy 5 ký tự đầu tiên của locale (dest) Ghép username (v3) Kết hợp tất cả thành mật khẩu (v6) Đầu tiên, khi ta xem lại thì gói main nằm ở No.168 và khi tra lại thì ta lấy được thời gian v1 rồi sau đó tính theo công thức để lấy s. v1 = 1743126530 s = v1 - v1 % 60 # 1743126480 Thứ hai về locate thì …","date":"2025-03-26 09:31:43","updated":"2025-03-26 09:31:43"},{"objectID":"f1d271e9fa638f9b264fddb058ea4111ba76dd97","permalink":"/post/picoctf2025/","title":"picoCTF 2025","content":" Theo cá nhân mình thấy các challenge về crypto của giải phân hóa rõ ràng các mức độ khác nhau\nGeneral FANTASY CTF Bài này mình nghĩ là chọn hướng nào cũng ra được vì đến cuối cùng sẽ đẩy ra flag :))\nFANTASY CTF SIMULATION The simulation begins in the private room of Eibhilin, a bright, young student. The room is dimly lit, with the glow of her multiple monitors casting an electric blue hue on the walls. Around the room are posters of vintage movies from the MCU — ancient guardians from another age staring down like digital sentinels. --- (Press Enter to continue...) --- Eibhilin stretches back in her chair, adjusting the holo-display of her keyboard. A soft hum of a nearby server fills the air as her AI companion, `Nyx`, comes to life. --- (Press Enter to continue...) --- \u0026amp;#34;Good evening, Ei,\u0026amp;#34; Nyx chirps, \u0026amp;#34;The 3025 edition of picoCTF registration is open. You asked me to remind so you could try out the competition for the first time. Do you wish to proceed?\u0026amp;#34; --- (Press …","date":"2025-03-22 13:52:19","updated":"2025-03-22 13:52:19"}]